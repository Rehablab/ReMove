<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Disruptor</name>
    </assembly>
    <members>
        <member name="T:Disruptor.AggregateEventHandler`1">
            <summary>
            An aggregate collection of <see cref="T:Disruptor.IEventHandler`1"/> that get called in sequence for each event.
            </summary>
            <typeparam name="T">event implementation storing the data for sharing during exchange or parallel coordination of an event</typeparam>
        </member>
        <member name="M:Disruptor.AggregateEventHandler`1.#ctor(Disruptor.IEventHandler{`0}[])">
            <summary>
            Construct an aggregate collection of <see cref="T:Disruptor.IEventHandler`1"/> to be called in sequence.
            </summary>
            <param name="eventHandlers">to be called in sequence</param>
        </member>
        <member name="M:Disruptor.AggregateEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)">
            <summary>
            Called when a publisher has committed an event to the <see cref="T:Disruptor.RingBuffer`1"/>
            </summary>
            <param name="data">Data committed to the <see cref="T:Disruptor.RingBuffer`1"/></param>
            <param name="sequence">Sequence number committed to the <see cref="T:Disruptor.RingBuffer`1"/></param>
            <param name="endOfBatch">flag to indicate if this is the last event in a batch from the <see cref="T:Disruptor.RingBuffer`1"/></param>
        </member>
        <member name="M:Disruptor.AggregateEventHandler`1.OnStart">
            <summary>
             Called once on thread start before first event is available.
            </summary>
        </member>
        <member name="M:Disruptor.AggregateEventHandler`1.OnShutdown">
            <summary>
            Called once just before the thread is shutdown.
            </summary>
        </member>
        <member name="T:Disruptor.AlertException">
            <summary>
            Used to alert <see cref="T:Disruptor.IEventProcessor"/>s waiting at a <see cref="T:Disruptor.ISequenceBarrier"/> of status changes.
            </summary>
        </member>
        <member name="F:Disruptor.AlertException.Instance">
            <summary>
            Pre-allocated exception to avoid garbage generation
            </summary>
        </member>
        <member name="M:Disruptor.AlertException.#ctor">
            <summary>
            Private constructor so only a single instance exists.
            </summary>
        </member>
        <member name="M:Disruptor.AlertException.Throw">
            <summary>
            Non-inlinable method helper to throw the exception.
            </summary>
        </member>
        <member name="T:Disruptor.BatchEventProcessor`1">
             <summary>
             Convenience class for handling the batching semantics of consuming events from a <see cref="T:Disruptor.RingBuffer`1"/>
             and delegating the available events to an <see cref="T:Disruptor.IEventHandler`1"/>.
            
             If the <see cref="T:Disruptor.IEventHandler`1"/> also implements <see cref="T:Disruptor.ILifecycleAware"/> it will be notified just after the thread
             is started and just before the thread is shutdown.
            
             This class is kept mainly for compatibility reasons.
            
             Consider using <see cref="T:Disruptor.BatchEventProcessorFactory"/> to create your <see cref="T:Disruptor.IEventProcessor"/>.
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`1.#ctor(Disruptor.IDataProvider{`0},Disruptor.ISequenceBarrier,Disruptor.IEventHandler{`0})">
             <summary>
             Construct a BatchEventProcessor that will automatically track the progress by updating its sequence when
             the <see cref="M:Disruptor.IEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)"/> method returns.
            
             Consider using <see cref="T:Disruptor.BatchEventProcessorFactory"/> to create your <see cref="T:Disruptor.IEventProcessor"/>.
             </summary>
             <param name="dataProvider">dataProvider to which events are published</param>
             <param name="sequenceBarrier">SequenceBarrier on which it is waiting.</param>
             <param name="eventHandler">eventHandler is the delegate to which events are dispatched.</param>
        </member>
        <member name="T:Disruptor.BatchEventProcessor`5">
             <summary>
             Convenience class for handling the batching semantics of consuming events from a <see cref="T:Disruptor.RingBuffer`1"/>
             and delegating the available events to an <see cref="T:Disruptor.IEventHandler`1"/>.
            
             If the <see cref="T:Disruptor.IEventHandler`1"/> also implements <see cref="T:Disruptor.ILifecycleAware"/> it will be notified just after the thread
             is started and just before the thread is shutdown.
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
             <typeparam name="TDataProvider">the type of the <see cref="T:Disruptor.IDataProvider`1"/> used.</typeparam>
             <typeparam name="TSequenceBarrier">the type of the <see cref="T:Disruptor.ISequenceBarrier"/> used.</typeparam>
             <typeparam name="TEventHandler">the type of the <see cref="T:Disruptor.IEventHandler`1"/> used.</typeparam>
             <typeparam name="TBatchStartAware">the type of the <see cref="T:Disruptor.IBatchStartAware"/> used.</typeparam>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.#ctor(`1,`2,`3,`4)">
             <summary>
             Construct a BatchEventProcessor that will automatically track the progress by updating its sequence when
             the <see cref="M:Disruptor.IEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)"/> method returns.
            
             Consider using <see cref="T:Disruptor.BatchEventProcessorFactory"/> to create your <see cref="T:Disruptor.IEventProcessor"/>.
             </summary>
             <param name="dataProvider">dataProvider to which events are published</param>
             <param name="sequenceBarrier">SequenceBarrier on which it is waiting.</param>
             <param name="eventHandler">eventHandler is the delegate to which events are dispatched.</param>
             <param name="batchStartAware"></param>
        </member>
        <member name="P:Disruptor.BatchEventProcessor`5.Sequence">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.Sequence"/>
            </summary>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.Halt">
            <summary>
            Signal that this <see cref="T:Disruptor.IEventProcessor"/> should stop when it has finished consuming at the next clean break.
            It will call <see cref="M:Disruptor.ISequenceBarrier.Alert"/> to notify the thread to check status.
            </summary>
        </member>
        <member name="P:Disruptor.BatchEventProcessor`5.IsRunning">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.IsRunning"/>
            </summary>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.SetExceptionHandler(Disruptor.IExceptionHandler{`0})">
            <summary>
            Set a new <see cref="T:Disruptor.IExceptionHandler`1"/> for handling exceptions propagated out of the <see cref="T:Disruptor.IEventHandler`1"/>
            </summary>
            <param name="exceptionHandler">exceptionHandler to replace the existing exceptionHandler.</param>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.WaitUntilStarted(System.TimeSpan)">
            <summary>
            Waits before the event processor enters the <see cref="P:Disruptor.BatchEventProcessor`5.IsRunning"/> state.
            </summary>
            <param name="timeout">maximum wait duration</param>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.Run">
            <summary>
            It is ok to have another thread rerun this method after a halt().
            </summary>
            <exception cref="T:System.InvalidOperationException">if this object instance is already running in a thread</exception>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.NotifyStart">
            <summary>
            Notifies the EventHandler when this processor is starting up
            </summary>
        </member>
        <member name="M:Disruptor.BatchEventProcessor`5.NotifyShutdown">
            <summary>
            Notifies the EventHandler immediately prior to this processor shutting down
            </summary>
        </member>
        <member name="T:Disruptor.BatchEventProcessorFactory">
            <summary>
            Factory that creates optimized instance of <see cref="T:Disruptor.IBatchEventProcessor`1"/>.
            </summary>
        </member>
        <member name="M:Disruptor.BatchEventProcessorFactory.Create``1(Disruptor.IDataProvider{``0},Disruptor.ISequenceBarrier,Disruptor.IEventHandler{``0})">
            <summary>
            Create a new <see cref="T:Disruptor.IBatchEventProcessor`1"/> with dedicated generic arguments.
            </summary>
            <typeparam name="T">the type of event used.</typeparam>
            <param name="dataProvider">dataProvider to which events are published</param>
            <param name="sequenceBarrier">SequenceBarrier on which it is waiting.</param>
            <param name="eventHandler">eventHandler is the delegate to which events are dispatched.</param>
            <returns></returns>
        </member>
        <member name="M:Disruptor.BatchEventProcessorFactory.Create``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequenceBarrier,Disruptor.IValueEventHandler{``0})">
            <summary>
            Create a new <see cref="T:Disruptor.IBatchEventProcessor`1"/> with dedicated generic arguments.
            </summary>
            <typeparam name="T">the type of event used.</typeparam>
            <param name="dataProvider">dataProvider to which events are published</param>
            <param name="sequenceBarrier">SequenceBarrier on which it is waiting.</param>
            <param name="eventHandler">eventHandler is the delegate to which events are dispatched.</param>
            <returns></returns>
        </member>
        <member name="T:Disruptor.BlockingSpinWaitWaitStrategy">
            <summary>
            Blocking strategy that uses a lock and condition variable for <see cref="T:Disruptor.IEventProcessor"/>s waiting on a barrier.
            This strategy uses a <see cref="T:System.Threading.SpinWait"/> when waiting for the dependent sequence to prevent excessive CPU usage.
            This strategy should be used when performance and low-latency are not as important as CPU resource.
            </summary>
        </member>
        <member name="M:Disruptor.BlockingSpinWaitWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.BlockingSpinWaitWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.BlockingWaitStrategy">
            <summary>
            Blocking strategy that uses a lock and condition variable for <see cref="T:Disruptor.IEventProcessor"/>s waiting on a barrier.
            
            This strategy should be used when performance and low-latency are not as important as CPU resource.
            </summary>
        </member>
        <member name="M:Disruptor.BlockingWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.BlockingWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.BusySpinWaitStrategy">
            <summary>
            Busy Spin strategy that uses a busy spin loop for <see cref="T:Disruptor.IEventProcessor"/>s waiting on a barrier.
            
            This strategy will use CPU resource to avoid syscalls which can introduce latency jitter.  It is best
            used when threads can be bound to specific CPU cores.
            </summary>
        </member>
        <member name="M:Disruptor.BusySpinWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.BusySpinWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.Dsl.BasicExecutor">
            <summary>
            TaskScheduler implementation for IExecutor
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.BasicExecutor.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Create a new <see cref="T:Disruptor.Dsl.BasicExecutor"/> with a given <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            that will handle low-level queuing of commands execution.
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.BasicExecutor.Execute(System.Action)">
            <summary>
            Start a new task executing the given command in the current TaskScheduler.
            </summary>
            <param name="command"></param>
        </member>
        <member name="T:Disruptor.Dsl.Disruptor`1">
             <summary>
             A DSL-style API for setting up the disruptor pattern around a ring buffer
             (aka the Builder pattern).
            
             A simple example of setting up the disruptor with two event handlers that
             must process events in order:
             <code>var disruptor = new Disruptor{MyEvent}(() => new MyEvent(), 32, TaskScheduler.Default);
             var handler1 = new EventHandler1() { ... };
             var handler2 = new EventHandler2() { ... };
             disruptor.HandleEventsWith(handler1).Then(handler2);
            
             var ringBuffer = disruptor.Start();</code>
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            Create a new Disruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.#ctor(System.Func{`0},System.Int32,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Create a new Disruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.#ctor(System.Func{`0},System.Int32,System.Threading.Tasks.TaskScheduler,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
            <summary>
            Create a new Disruptor.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
            <param name="producerType">the claim strategy to use for the ring buffer</param>
            <param name="waitStrategy">the wait strategy to use for the ring buffer</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.#ctor(System.Func{`0},System.Int32,Disruptor.Dsl.IExecutor)">
            <summary>
            Create a new Disruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="executor">an <see cref="T:Disruptor.Dsl.IExecutor"/> to create threads for processors</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleEventsWith(Disruptor.IEventHandler{`0}[])">
             <summary>
             Set up event handlers to handle events from the ring buffer. These handlers will process events
             as soon as they become available, in parallel.
            
             <code>dw.HandleEventsWith(A).Then(B);</code>
            
             This call is additive, but generally should only be called once when setting up the disruptor instance.
             </summary>
             <param name="handlers">the event handlers that will process events</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleEventsWith(Disruptor.Dsl.IEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The disruptor will
             automatically start these processors when <see cref="M:Disruptor.Dsl.Disruptor`1.Start"/> is called.
            
             This method can be used as the start of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).Then(B);</code>
            
             Since this is the start of the chain, the processor factories will always be passed an empty <code>Sequence</code>
             array, so the factory isn't necessary in this case. This method is provided for consistency with
             <see cref="M:Disruptor.Dsl.EventHandlerGroup`1.HandleEventsWith(Disruptor.Dsl.IEventProcessorFactory{`0}[])"/> and <see cref="M:Disruptor.Dsl.EventHandlerGroup`1.Then(Disruptor.Dsl.IEventProcessorFactory{`0}[])"/>
             which do have barrier sequences to provide.
            
             This call is additive, but generally should only be called once when setting up the disruptor instance.
             </summary>
             <param name="eventProcessorFactories">eventProcessorFactories the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleEventsWith(Disruptor.IEventProcessor[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The disruptor will
             automatically start this processors when <see cref="M:Disruptor.Dsl.Disruptor`1.Start"/> is called.
            
             This method can be used as the start of a chain. For example if the processor <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).Then(B);</code>
             </summary>
             <param name="processors">processors the event processors that will process events</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleEventsWithWorkerPool(Disruptor.IWorkHandler{`0}[])">
            <summary>
            Set up a <see cref="T:Disruptor.WorkerPool`1"/> to distribute an event to one of a pool of work handler threads.
            Each event will only be processed by one of the work handlers.
            The disruptor will automatically start this processors when <see cref="M:Disruptor.Dsl.Disruptor`1.Start"/> is called.
            </summary>
            <param name="workHandlers">the work handlers that will process events.</param>
            <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleExceptionsWith(Disruptor.IExceptionHandler{System.Object})">
            <summary>
            Specify an exception handler to be used for any future event handlers.
            Note that only event handlers set up after calling this method will use the exception handler.
            </summary>
            <param name="exceptionHandler">the exception handler to use for any future <see cref="T:Disruptor.IEventProcessor"/>.</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.SetDefaultExceptionHandler(Disruptor.IExceptionHandler{`0})">
            <summary>
            Specify an exception handler to be used for event handlers and worker pools created by this disruptor.
            The exception handler will be used by existing and future event handlers and worker pools created by this disruptor instance.
            </summary>
            <param name="exceptionHandler">the exception handler to use</param>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HandleExceptionsFor(Disruptor.IEventHandler{`0})">
            <summary>
            Override the default exception handler for a specific handler.
            <code>disruptorWizard.HandleExceptionsIn(eventHandler).With(exceptionHandler);</code>
            </summary>
            <param name="eventHandler">eventHandler the event handler to set a different exception handler for</param>
            <returns>an <see cref="T:Disruptor.Dsl.ExceptionHandlerSetting`1"/> dsl object - intended to be used by chaining the with method call</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.After(Disruptor.IEventHandler{`0}[])">
            <summary>
            Create a group of event handlers to be used as a dependency.
            For example if the handler <code>A</code> must process events before handler <code>B</code>:
            <code>dw.After(A).HandleEventsWith(B);</code>
            </summary>
            <param name="handlers">handlers the event handlers, previously set up with <see cref="M:Disruptor.Dsl.Disruptor`1.HandleEventsWith(Disruptor.IEventHandler{`0}[])"/>,
            that will form the barrier for subsequent handlers or processors.</param>
            <returns>an <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to setup a dependency barrier over the specified event handlers.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.After(Disruptor.IEventProcessor[])">
            <summary>
            Create a group of event processors to be used as a dependency.
            </summary>
            <see cref="M:Disruptor.Dsl.Disruptor`1.After(Disruptor.IEventHandler{`0}[])"/>
            <param name="processors">processors the event processors, previously set up with <see cref="M:Disruptor.Dsl.Disruptor`1.HandleEventsWith(Disruptor.IEventHandler{`0}[])"/>,
            that will form the barrier for subsequent handlers or processors.</param>
            <returns>an <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to setup a <see cref="T:Disruptor.ISequenceBarrier"/> over the specified event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.PublishEvent">
            <summary>
            <see cref="M:Disruptor.RingBuffer`1.PublishEvent"/>
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.PublishEvents(System.Int32)">
            <summary>
            <see cref="M:Disruptor.RingBuffer`1.PublishEvents(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.Start">
             <summary>
             Starts the event processors and returns the fully configured ring buffer.
            
             The ring buffer is set up to prevent overwriting any entry that is yet to
             be processed by the slowest event processor.
            
             This method must only be called once after all event processors have been added.
             </summary>
             <returns>the configured ring buffer</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.Halt">
            <summary>
            Calls <see cref="M:Disruptor.IEventProcessor.Halt"/> on all of the event processors created via this disruptor.
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.Shutdown">
             <summary>
             Waits until all events currently in the disruptor have been processed by all event processors
             and then halts the processors.It is critical that publishing to the ring buffer has stopped
             before calling this method, otherwise it may never return.
            
             This method will not shutdown the executor, nor will it await the final termination of the
             processor threads
             </summary>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.Shutdown(System.TimeSpan)">
             <summary>
             Waits until all events currently in the disruptor have been processed by all event processors
             and then halts the processors.
            
             This method will not shutdown the executor, nor will it await the final termination of the
             processor threads
             </summary>
             <param name="timeout">the amount of time to wait for all events to be processed. <code>TimeSpan.MaxValue</code> will give an infinite timeout</param>
             <exception cref="T:Disruptor.TimeoutException">if a timeout occurs before shutdown completes.</exception>
        </member>
        <member name="P:Disruptor.Dsl.Disruptor`1.RingBuffer">
            <summary>
            The <see cref="T:Disruptor.RingBuffer`1"/> used by this disruptor. This is useful for creating custom
            event processors if the behaviour of <see cref="T:Disruptor.BatchEventProcessor`1"/> is not suitable.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.Disruptor`1.Cursor">
            <summary>
            Get the value of the cursor indicating the published sequence.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.Disruptor`1.BufferSize">
            <summary>
            The capacity of the data structure to hold entries.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.Disruptor`1.Item(System.Int64)">
            <summary>
            Get the event for a given sequence in the RingBuffer.
            <see cref="P:Disruptor.RingBuffer`1.Item(System.Int64)"/>
            </summary>
            <param name="sequence">sequence for the event</param>
            <returns>event for the sequence</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.GetBarrierFor(Disruptor.IEventHandler{`0})">
            <summary>
            Get the <see cref="T:Disruptor.ISequenceBarrier"/> used by a specific handler. Note that the <see cref="T:Disruptor.ISequenceBarrier"/>
            may be shared by multiple event handlers.
            </summary>
            <param name="handler">the handler to get the barrier for</param>
            <returns>the SequenceBarrier used by the given handler</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.GetSequenceValueFor(Disruptor.IEventHandler{`0})">
            <summary>
            Gets the sequence value for the specified event handlers.
            </summary>
            <param name="handler">eventHandler to get the sequence for.</param>
            <returns>eventHandler's sequence</returns>
        </member>
        <member name="M:Disruptor.Dsl.Disruptor`1.HasBacklog">
            <summary>
            Confirms if all messages have been consumed by all event processors
            </summary>
            <returns></returns>
        </member>
        <member name="T:Disruptor.Dsl.EventHandlerGroup`1">
            <summary>
             A group of <see cref="T:Disruptor.IEventProcessor"/>s used as part of the <see cref="T:Disruptor.Dsl.Disruptor`1"/>
            </summary>
            <typeparam name="T">the type of event used by <see cref="T:Disruptor.IEventProcessor"/>s.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.And(Disruptor.Dsl.EventHandlerGroup{`0})">
            <summary>
            Create a new event handler group that combines the consumers in this group with <paramref name="otherHandlerGroup"/>
            </summary>
            <param name="otherHandlerGroup">the event handler group to combine</param>
            <returns>a new EventHandlerGroup combining the existing and new consumers into a single dependency group</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.And(Disruptor.IEventProcessor[])">
            <summary>
            Create a new event handler group that combines the handlers in this group with <paramref name="processors"/>.
            </summary>
            <param name="processors">the processors to combine</param>
            <returns>a new EventHandlerGroup combining the existing and new processors into a single dependency group</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.Then(Disruptor.IEventHandler{`0}[])">
             <summary>
             Set up batch handlers to consume events from the ring buffer. These handlers will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).then(B);</code>
             </summary>
             <param name="handlers"></param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.Then(Disruptor.Dsl.IEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The Disruptor will
             automatically start these processors when started.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             </summary>
             <param name="eventProcessorFactories">the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.ThenHandleEventsWithWorkerPool(Disruptor.IWorkHandler{`0}[])">
             <summary>
             Set up a worker pool to handle events from the ring buffer. The worker pool will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event. Each event will be processed
             by one of the work handler instances.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before the worker pool with handlers <code>B, C</code>:
             <code>dw.HandleEventsWith(A).ThenHandleEventsWithWorkerPool(B, C);</code>
             </summary>
             <param name="handlers">the work handlers that will process events. Each work handler instance will provide an extra thread in the worker pool.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to set up a event processor barrier over the created event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.HandleEventsWith(Disruptor.IEventHandler{`0}[])">
             <summary>
             Set up batch handlers to handle events from the ring buffer. These handlers will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event.
            
             This method is generally used as part of a chain. For example if <code>A</code> must
             process events before<code> B</code>:
             <code>dw.After(A).HandleEventsWith(B);</code>
             </summary>
             <param name="handlers">the batch handlers that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to set up a event processor barrier over the created event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.HandleEventsWith(Disruptor.Dsl.IEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The Disruptor will
             automatically start these processors when started.
            
             This method is generally used as part of a chain. For example if <code>A</code> must
             process events before<code> B</code>:
             <code>dw.After(A).HandleEventsWith(B);</code>
             </summary>
             <param name="eventProcessorFactories">eventProcessorFactories the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.HandleEventsWithWorkerPool(Disruptor.IWorkHandler{`0}[])">
             <summary>
             Set up a worker pool to handle events from the ring buffer. The worker pool will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event. Each event will be processed
             by one of the work handler instances.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before the worker pool with handlers <code>B, C</code>:
             <code>dw.After(A).HandleEventsWithWorkerPool(B, C);</code>
             </summary>
             <param name="handlers">handlers the work handlers that will process events. Each work handler instance will provide an extra thread in the worker pool.</param>
             <returns>a <see cref="T:Disruptor.Dsl.EventHandlerGroup`1"/> that can be used to set up a event processor barrier over the created event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.EventHandlerGroup`1.AsSequenceBarrier">
            <summary>
            Create a dependency barrier for the processors in this group.
            This allows custom event processors to have dependencies on
            <see cref="T:Disruptor.IBatchEventProcessor`1"/>s created by the disruptor.
            </summary>
            <returns>a <see cref="T:Disruptor.ISequenceBarrier"/> including all the processors in this group.</returns>
        </member>
        <member name="T:Disruptor.Dsl.EventProcessorInfo">
            <summary>
            Wrapper class to tie together a particular event processing stage
            
            Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to.
            </summary>
        </member>
        <member name="T:Disruptor.Dsl.ExceptionHandlerSetting`1">
            <summary>
            A support class used as part of setting an exception handler for a specific event handler.
            For example:
            <code>disruptorWizard.HandleExceptionsIn(eventHandler).With(exceptionHandler);</code>
            </summary>
            <typeparam name="T">the type of event being handled.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.ExceptionHandlerSetting`1.With(Disruptor.IExceptionHandler{`0})">
            <summary>
            Specify the <see cref="T:Disruptor.IExceptionHandler`1"/> to use with the event handler.
            </summary>
            <param name="exceptionHandler">exceptionHandler the exception handler to use.</param>
        </member>
        <member name="T:Disruptor.Dsl.IEventProcessorFactory`1">
            <summary>
            A factory interface to make it possible to include custom event processors in a chain:
            
            <code>disruptor.HandleEventsWith(handler1).Then((ringBuffer, barrierSequences) -> new CustomEventProcessor(ringBuffer, barrierSequences));</code>
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.IEventProcessorFactory`1.CreateEventProcessor(Disruptor.RingBuffer{`0},Disruptor.ISequence[])">
            <summary>
            Create a new event processor that gates on <paramref name="barrierSequences"/>
            </summary>
            <param name="ringBuffer">the ring buffer to receive events from.</param>
            <param name="barrierSequences">barrierSequences the sequences to gate on</param>
            <returns>a new EventProcessor that gates on <code>barrierSequences</code> before processing events</returns>
        </member>
        <member name="T:Disruptor.Dsl.IExecutor">
            <summary>
            Replace the Executor interface in java.util.concurrent
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.IExecutor.Execute(System.Action)">
            <summary>
            Execute the given command in an other thread
            </summary>
            <param name="command">The command to execute</param>
        </member>
        <member name="T:Disruptor.Dsl.IValueEventProcessorFactory`1">
             <summary>
             A factory interface to make it possible to include custom event processors in a chain:
            
             <code>disruptor.HandleEventsWith(handler1).Then((ringBuffer, barrierSequences) -> new CustomEventProcessor(ringBuffer, barrierSequences));</code>
             </summary>
        </member>
        <member name="M:Disruptor.Dsl.IValueEventProcessorFactory`1.CreateEventProcessor(Disruptor.IValueRingBuffer{`0},Disruptor.ISequence[])">
            <summary>
            Create a new event processor that gates on <paramref name="barrierSequences"/>
            </summary>
            <param name="ringBuffer">the ring buffer to receive events from.</param>
            <param name="barrierSequences">barrierSequences the sequences to gate on</param>
            <returns>a new EventProcessor that gates on <code>barrierSequences</code> before processing events</returns>
        </member>
        <member name="T:Disruptor.Dsl.ProducerType">
            <summary>
            Defines producer types to support creation of RingBuffer with correct sequencer and publisher.
            </summary>
        </member>
        <member name="F:Disruptor.Dsl.ProducerType.Single">
            <summary>
            Create a RingBuffer with a single event publisher to the RingBuffer
            </summary>
        </member>
        <member name="F:Disruptor.Dsl.ProducerType.Multi">
            <summary>
            Create a RingBuffer supporting multiple event publishers to the one RingBuffer
            </summary>
        </member>
        <member name="T:Disruptor.Dsl.SequencerFactory">
            <summary>
            Extension methods for <see cref="T:Disruptor.Dsl.ProducerType"/>.
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.SequencerFactory.DefaultWaitStrategy">
            <summary>
            Creates default <see cref="T:Disruptor.IWaitStrategy"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Disruptor.Dsl.SequencerFactory.Create(Disruptor.Dsl.ProducerType,System.Int32)">
            <summary>
            Create a new sequencer with the specified producer type and <see cref="T:Disruptor.BlockingWaitStrategy"/>.
            </summary>
            <param name="producerType">producer type to use <see cref="T:Disruptor.Dsl.ProducerType" /></param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the producer type is invalid</exception>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.Dsl.SequencerFactory.Create(Disruptor.Dsl.ProducerType,System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new sequencer with the specified producer type.
            </summary>
            <param name="producerType">producer type to use <see cref="T:Disruptor.Dsl.ProducerType" /></param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the producer type is invalid</exception>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="T:Disruptor.Dsl.UnmanagedDisruptor`1">
            <summary>
            A DSL-style API for setting up the disruptor pattern around a ring buffer
            (aka the Builder pattern).
            </summary>
            <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Create a new UnmanagedDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="pointer">pointer to the first event of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="ringBufferSize">the number of events of the ring buffer, must be power of 2</param>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(System.IntPtr,System.Int32,System.Int32,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Create a new UnmanagedDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="pointer">pointer to the first event of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="ringBufferSize">the number of events of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(System.IntPtr,System.Int32,System.Int32,Disruptor.Dsl.IExecutor)">
            <summary>
            Create a new UnmanagedDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="pointer">pointer to the first event of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="ringBufferSize">the number of events of the ring buffer, must be power of 2</param>
            <param name="executor">an <see cref="T:Disruptor.Dsl.IExecutor"/> to create threads for processors</param>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(System.IntPtr,System.Int32,System.Int32,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
            <summary>
            Create a new UnmanagedDisruptor.
            </summary>
            <param name="pointer">pointer to the first event of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="ringBufferSize">the number of events of the ring buffer, must be power of 2</param>
            <param name="producerType">the claim strategy to use for the ring buffer</param>
            <param name="waitStrategy">the wait strategy to use for the ring buffer</param>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(Disruptor.UnmanagedRingBufferMemory,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
             <summary>
             Create a new UnmanagedDisruptor.
            
             The <see cref="T:Disruptor.UnmanagedRingBufferMemory"/> is not owned by the disruptor and should be disposed after shutdown.
             </summary>
             <param name="memory">block of memory that will store the events</param>
             <param name="producerType">the claim strategy to use for the ring buffer</param>
             <param name="waitStrategy">the wait strategy to use for the ring buffer</param>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.#ctor(System.IntPtr,System.Int32,System.Int32,System.Threading.Tasks.TaskScheduler,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
            <summary>
            Create a new UnmanagedDisruptor.
            </summary>
            <param name="pointer">pointer to the first event of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="ringBufferSize">the number of events of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
            <param name="producerType">the claim strategy to use for the ring buffer</param>
            <param name="waitStrategy">the wait strategy to use for the ring buffer</param>
        </member>
        <member name="P:Disruptor.Dsl.UnmanagedDisruptor`1.RingBuffer">
            <summary>
            The <see cref="T:Disruptor.UnmanagedRingBuffer`1"/> used by this disruptor. This is useful for creating custom
            event processors if the behaviour of <see cref="T:Disruptor.IValueBatchEventProcessor`1"/> is not suitable.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.UnmanagedDisruptor`1.Cursor">
            <summary>
            Get the value of the cursor indicating the published sequence.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.UnmanagedDisruptor`1.BufferSize">
            <summary>
            The capacity of the data structure to hold entries.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.UnmanagedDisruptor`1.Item(System.Int64)">
            <summary>
            Get the event for a given sequence in the RingBuffer.
            </summary>
            <param name="sequence">sequence for the event</param>
            <returns>event for the sequence</returns>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.PublishEvent">
            <summary>
            <see cref="M:Disruptor.UnmanagedRingBuffer`1.PublishEvent"/>
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.UnmanagedDisruptor`1.PublishEvents(System.Int32)">
            <summary>
            <see cref="M:Disruptor.UnmanagedRingBuffer`1.PublishEvents(System.Int32)"/>
            </summary>
        </member>
        <member name="T:Disruptor.Dsl.ValueDisruptor`1">
             <summary>
             A DSL-style API for setting up the disruptor pattern around a ring buffer
             (aka the Builder pattern).
            
             A simple example of setting up the disruptor with two event handlers that
             must process events in order:
             <code>var disruptor = new ValueDisruptor{MyEvent}(() => new MyEvent(), 32, TaskScheduler.Default);
             var handler1 = new EventHandler1{MyEvent}() { ... };
             var handler2 = new EventHandler2{MyEvent}() { ... };
             disruptor.HandleEventsWith(handler1).Then(handler2);
            
             var ringBuffer = disruptor.Start();</code>
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            Create a new ValueDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.#ctor(System.Func{`0},System.Int32,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Create a new ValueDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.#ctor(System.Func{`0},System.Int32,System.Threading.Tasks.TaskScheduler,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
            <summary>
            Create a new ValueDisruptor.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="taskScheduler">a <see cref="T:System.Threading.Tasks.TaskScheduler"/> to create threads for processors</param>
            <param name="producerType">the claim strategy to use for the ring buffer</param>
            <param name="waitStrategy">the wait strategy to use for the ring buffer</param>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.#ctor(System.Func{`0},System.Int32,Disruptor.Dsl.IExecutor)">
            <summary>
            Create a new ValueDisruptor. Will default to <see cref="T:Disruptor.BlockingWaitStrategy"/> and <see cref="F:Disruptor.Dsl.ProducerType.Multi"/>.
            </summary>
            <param name="eventFactory">the factory to create events in the ring buffer</param>
            <param name="ringBufferSize">the size of the ring buffer, must be power of 2</param>
            <param name="executor">an <see cref="T:Disruptor.Dsl.IExecutor"/> to create threads for processors</param>
        </member>
        <member name="P:Disruptor.Dsl.ValueDisruptor`1.RingBuffer">
            <summary>
            The <see cref="T:Disruptor.ValueRingBuffer`1"/> used by this disruptor. This is useful for creating custom
            event processors if the behaviour of <see cref="T:Disruptor.IValueBatchEventProcessor`1"/> is not suitable.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.ValueDisruptor`1.Cursor">
            <summary>
            Get the value of the cursor indicating the published sequence.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.ValueDisruptor`1.BufferSize">
            <summary>
            The capacity of the data structure to hold entries.
            </summary>
        </member>
        <member name="P:Disruptor.Dsl.ValueDisruptor`1.Item(System.Int64)">
            <summary>
            Get the event for a given sequence in the RingBuffer.
            </summary>
            <param name="sequence">sequence for the event</param>
            <returns>event for the sequence</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.PublishEvent">
            <summary>
            <see cref="M:Disruptor.ValueRingBuffer`1.PublishEvent"/>
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`1.PublishEvents(System.Int32)">
            <summary>
            <see cref="M:Disruptor.ValueRingBuffer`1.PublishEvents(System.Int32)"/>
            </summary>
        </member>
        <member name="T:Disruptor.Dsl.ValueDisruptor`2">
             <summary>
             Base class for disruptors of value type events.
            
             <see cref="T:Disruptor.Dsl.ValueDisruptor`1"/> and <see cref="T:Disruptor.Dsl.UnmanagedDisruptor`1"/>.
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
             <typeparam name="TRingBuffer">the type of the underlying ring buffer.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.HandleEventsWith(Disruptor.IValueEventHandler{`0}[])">
             <summary>
             Set up event handlers to handle events from the ring buffer. These handlers will process events
             as soon as they become available, in parallel.
            
             <code>dw.HandleEventsWith(A).Then(B);</code>
            
             This call is additive, but generally should only be called once when setting up the disruptor instance.
             </summary>
             <param name="handlers">the event handlers that will process events</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.HandleEventsWith(Disruptor.IEventProcessor[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The disruptor will
             automatically start this processors when <see cref="M:Disruptor.Dsl.ValueDisruptor`2.Start"/> is called.
            
             This method can be used as the start of a chain. For example if the processor <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).Then(B);</code>
             </summary>
             <param name="processors">processors the event processors that will process events</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.SetDefaultExceptionHandler(Disruptor.IValueExceptionHandler{`0})">
            <summary>
            Specify an exception handler to be used for event handlers and worker pools created by this disruptor.
            The exception handler will be used by existing and future event handlers and worker pools created by this disruptor instance.
            </summary>
            <param name="exceptionHandler">the exception handler to use</param>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.HandleExceptionsFor(Disruptor.IValueEventHandler{`0})">
            <summary>
            Override the default exception handler for a specific handler.
            <code>disruptorWizard.HandleExceptionsIn(eventHandler).With(exceptionHandler);</code>
            </summary>
            <param name="eventHandler">eventHandler the event handler to set a different exception handler for</param>
            <returns>an <see cref="T:Disruptor.Dsl.ValueExceptionHandlerSetting`1"/> dsl object - intended to be used by chaining the with method call</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.After(Disruptor.IValueEventHandler{`0}[])">
            <summary>
            Create a group of event handlers to be used as a dependency.
            For example if the handler <code>A</code> must process events before handler <code>B</code>:
            <code>dw.After(A).HandleEventsWith(B);</code>
            </summary>
            <param name="handlers">handlers the event handlers, previously set up with <see cref="M:Disruptor.Dsl.ValueDisruptor`2.HandleEventsWith(Disruptor.IValueEventHandler{`0}[])"/>,
            that will form the barrier for subsequent handlers or processors.</param>
            <returns>an <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to setup a dependency barrier over the specified event handlers.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.HandleEventsWith(Disruptor.Dsl.IValueEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The disruptor will
             automatically start these processors when <see cref="M:Disruptor.Dsl.ValueDisruptor`2.Start"/> is called.
            
             This method can be used as the start of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).Then(B);</code>
            
             Since this is the start of the chain, the processor factories will always be passed an empty <code>Sequence</code>
             array, so the factory isn't necessary in this case. This method is provided for consistency with
             <see cref="M:Disruptor.Dsl.ValueEventHandlerGroup`1.HandleEventsWith(Disruptor.Dsl.IValueEventProcessorFactory{`0}[])"/> and <see cref="M:Disruptor.Dsl.ValueEventHandlerGroup`1.Then(Disruptor.Dsl.IValueEventProcessorFactory{`0}[])"/>
             which do have barrier sequences to provide.
            
             This call is additive, but generally should only be called once when setting up the disruptor instance.
             </summary>
             <param name="eventProcessorFactories">eventProcessorFactories the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.After(Disruptor.IEventProcessor[])">
            <summary>
            Create a group of event processors to be used as a dependency.
            </summary>
            <see cref="M:Disruptor.Dsl.ValueDisruptor`2.After(Disruptor.IValueEventHandler{`0}[])"/>
            <param name="processors">processors the event processors, previously set up with <see cref="M:Disruptor.Dsl.ValueDisruptor`2.HandleEventsWith(Disruptor.IValueEventHandler{`0}[])"/>,
            that will form the barrier for subsequent handlers or processors.</param>
            <returns>an <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to setup a <see cref="T:Disruptor.ISequenceBarrier"/> over the specified event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.Start">
             <summary>
             Starts the event processors and returns the fully configured ring buffer.
            
             The ring buffer is set up to prevent overwriting any entry that is yet to
             be processed by the slowest event processor.
            
             This method must only be called once after all event processors have been added.
             </summary>
             <returns>the configured ring buffer</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.Halt">
            <summary>
            Calls <see cref="M:Disruptor.IEventProcessor.Halt"/> on all of the event processors created via this disruptor.
            </summary>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.Shutdown">
             <summary>
             Waits until all events currently in the disruptor have been processed by all event processors
             and then halts the processors.It is critical that publishing to the ring buffer has stopped
             before calling this method, otherwise it may never return.
            
             This method will not shutdown the executor, nor will it await the final termination of the
             processor threads
             </summary>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.Shutdown(System.TimeSpan)">
             <summary>
             Waits until all events currently in the disruptor have been processed by all event processors
             and then halts the processors.
            
             This method will not shutdown the executor, nor will it await the final termination of the
             processor threads
             </summary>
             <param name="timeout">the amount of time to wait for all events to be processed. <code>TimeSpan.MaxValue</code> will give an infinite timeout</param>
             <exception cref="T:Disruptor.TimeoutException">if a timeout occurs before shutdown completes.</exception>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.GetBarrierFor(Disruptor.IValueEventHandler{`0})">
            <summary>
            Get the <see cref="T:Disruptor.ISequenceBarrier"/> used by a specific handler. Note that the <see cref="T:Disruptor.ISequenceBarrier"/>
            may be shared by multiple event handlers.
            </summary>
            <param name="handler">the handler to get the barrier for</param>
            <returns>the SequenceBarrier used by the given handler</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.GetSequenceValueFor(Disruptor.IValueEventHandler{`0})">
            <summary>
            Gets the sequence value for the specified event handlers.
            </summary>
            <param name="handler">eventHandler to get the sequence for.</param>
            <returns>eventHandler's sequence</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueDisruptor`2.HasBacklog">
            <summary>
            Confirms if all messages have been consumed by all event processors
            </summary>
            <returns></returns>
        </member>
        <member name="T:Disruptor.Dsl.ValueEventHandlerGroup`1">
            <summary>
             A group of <see cref="T:Disruptor.IEventProcessor"/>s used as part of the <see cref="T:Disruptor.Dsl.ValueDisruptor`1"/>
            </summary>
            <typeparam name="T">the type of event used by <see cref="T:Disruptor.IEventProcessor"/>s.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.And(Disruptor.Dsl.ValueEventHandlerGroup{`0})">
            <summary>
            Create a new event handler group that combines the consumers in this group with <paramref name="otherHandlerGroup"/>
            </summary>
            <param name="otherHandlerGroup">the event handler group to combine</param>
            <returns>a new ValueEventHandlerGroup combining the existing and new consumers into a single dependency group</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.And(Disruptor.IEventProcessor[])">
            <summary>
            Create a new event handler group that combines the handlers in this group with <paramref name="processors"/>.
            </summary>
            <param name="processors">the processors to combine</param>
            <returns>a new ValueEventHandlerGroup combining the existing and new processors into a single dependency group</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.Then(Disruptor.IValueEventHandler{`0}[])">
             <summary>
             Set up batch handlers to consume events from the ring buffer. These handlers will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             <code>dw.HandleEventsWith(A).then(B);</code>
             </summary>
             <param name="handlers"></param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.Then(Disruptor.Dsl.IValueEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The Disruptor will
             automatically start these processors when started.
            
             This method is generally used as part of a chain. For example if the handler <code>A</code> must
             process events before handler<code>B</code>:
             </summary>
             <param name="eventProcessorFactories">the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.HandleEventsWith(Disruptor.IValueEventHandler{`0}[])">
             <summary>
             Set up batch handlers to handle events from the ring buffer. These handlers will only process events
             after every <see cref="T:Disruptor.IEventProcessor"/> in this group has processed the event.
            
             This method is generally used as part of a chain. For example if <code>A</code> must
             process events before<code> B</code>:
             <code>dw.After(A).HandleEventsWith(B);</code>
             </summary>
             <param name="handlers">the batch handlers that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to set up a event processor barrier over the created event processors.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.HandleEventsWith(Disruptor.Dsl.IValueEventProcessorFactory{`0}[])">
             <summary>
             Set up custom event processors to handle events from the ring buffer. The Disruptor will
             automatically start these processors when started.
            
             This method is generally used as part of a chain. For example if <code>A</code> must
             process events before<code> B</code>:
             <code>dw.After(A).HandleEventsWith(B);</code>
             </summary>
             <param name="eventProcessorFactories">eventProcessorFactories the event processor factories to use to create the event processors that will process events.</param>
             <returns>a <see cref="T:Disruptor.Dsl.ValueEventHandlerGroup`1"/> that can be used to chain dependencies.</returns>
        </member>
        <member name="M:Disruptor.Dsl.ValueEventHandlerGroup`1.AsSequenceBarrier">
            <summary>
            Create a dependency barrier for the processors in this group.
            This allows custom event processors to have dependencies on
            <see cref="T:Disruptor.IValueBatchEventProcessor`1"/>s created by the disruptor.
            </summary>
            <returns>a <see cref="T:Disruptor.ISequenceBarrier"/> including all the processors in this group.</returns>
        </member>
        <member name="T:Disruptor.Dsl.ValueExceptionHandlerSetting`1">
            <summary>
            A support class used as part of setting an exception handler for a specific event handler.
            For example:
            <code>disruptorWizard.HandleExceptionsIn(eventHandler).With(exceptionHandler);</code>
            </summary>
            <typeparam name="T">the type of event being handled.</typeparam>
        </member>
        <member name="M:Disruptor.Dsl.ValueExceptionHandlerSetting`1.With(Disruptor.IValueExceptionHandler{`0})">
            <summary>
            Specify the <see cref="T:Disruptor.IValueExceptionHandler`1"/> to use with the event handler.
            </summary>
            <param name="exceptionHandler">exceptionHandler the exception handler to use.</param>
        </member>
        <member name="T:Disruptor.EventPoller`1">
            <summary>
            Experimental poll-based interface for the Disruptor.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Disruptor.FatalExceptionHandler">
            <summary>
            Convenience implementation of an exception handler that using standard Console.Writeline to log
            the exception re-throw it wrapped in a <see cref="T:System.ApplicationException"/>
            </summary>
        </member>
        <member name="M:Disruptor.FatalExceptionHandler.HandleEventException(System.Exception,System.Int64,System.Object)">
            <summary>
            Strategy for handling uncaught exceptions when processing an event.
            </summary>
            <param name="ex">exception that propagated from the <see cref="T:Disruptor.IEventHandler`1"/>.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
            <param name="evt">event being processed when the exception occurred.</param>
        </member>
        <member name="M:Disruptor.FatalExceptionHandler.HandleOnStartException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnStart"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
        </member>
        <member name="M:Disruptor.FatalExceptionHandler.HandleOnShutdownException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnShutdown"/>
            </summary>
            <param name="ex">ex throw during the shutdown process.</param>
        </member>
        <member name="T:Disruptor.IBatchEventProcessor`1">
            <summary>
            Interface for <see cref="T:Disruptor.BatchEventProcessor`5"/>.
            </summary>
            <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.IBatchEventProcessor`1.WaitUntilStarted(System.TimeSpan)">
            <summary>
            Waits before the event processor enters the <see cref="P:Disruptor.IEventProcessor.IsRunning"/> state.
            </summary>
            <param name="timeout">maximum wait duration</param>
        </member>
        <member name="M:Disruptor.IBatchEventProcessor`1.SetExceptionHandler(Disruptor.IExceptionHandler{`0})">
            <summary>
            Set a new <see cref="T:Disruptor.IExceptionHandler`1"/> for handling exceptions propagated out of the <see cref="T:Disruptor.IEventHandler`1"/>
            </summary>
            <param name="exceptionHandler">exceptionHandler to replace the existing exceptionHandler.</param>
        </member>
        <member name="T:Disruptor.IBatchStartAware">
            <summary>
            Implement this interface in your event handler to be notified when a batch is starting.
            </summary>
        </member>
        <member name="M:Disruptor.IBatchStartAware.OnBatchStart(System.Int64)">
            <summary>
            Called on each batch start before the first call to <see cref="M:Disruptor.IEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)"/> or <see cref="M:Disruptor.IValueEventHandler`1.OnEvent(`0@,System.Int64,System.Boolean)"/>.
            </summary>
            <param name="batchSize">the batch size.</param>
        </member>
        <member name="T:Disruptor.ICursored">
            <summary>
            Implementors of this interface must provide a single long value
            that represents their current cursor value.Used during dynamic
            add/remove of Sequences from a
            <see cref="M:Disruptor.SequenceGroups.AddSequences(Disruptor.ISequence[]@,Disruptor.ICursored,Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="P:Disruptor.ICursored.Cursor">
            <summary>
            Get the current cursor value.
            </summary>
        </member>
        <member name="T:Disruptor.IEventHandler`1">
            <summary>
            Callback interface to be implemented for processing events as they become available in the <see cref="T:Disruptor.RingBuffer`1"/>
            </summary>
            <typeparam name="T">Type of events for sharing during exchange or parallel coordination of an event.</typeparam>
            <remarks>See <see cref="M:Disruptor.IBatchEventProcessor`1.SetExceptionHandler(Disruptor.IExceptionHandler{`0})"/> if you want to handle exceptions propagated out of the handler.</remarks>
        </member>
        <member name="M:Disruptor.IEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)">
            <summary>
            Called when a publisher has committed an event to the <see cref="T:Disruptor.RingBuffer`1"/>. The <see cref="T:Disruptor.IBatchEventProcessor`1"/> will
            read messages from the <see cref="T:Disruptor.RingBuffer`1"/> in batches, where a batch is all of the events available to be
            processed without having to wait for any new event to arrive.  This can be useful for event handlers that need
            to do slower operations like I/O as they can group together the data from multiple events into a single
            operation.  Implementations should ensure that the operation is always performed when endOfBatch is true as
            the time between that message an the next one is indeterminate.
            </summary>
            <param name="data">Data committed to the <see cref="T:Disruptor.RingBuffer`1"/></param>
            <param name="sequence">Sequence number committed to the <see cref="T:Disruptor.RingBuffer`1"/></param>
            <param name="endOfBatch">flag to indicate if this is the last event in a batch from the <see cref="T:Disruptor.RingBuffer`1"/></param>
        </member>
        <member name="T:Disruptor.IEventProcessor">
            <summary>
            An IEventProcessor needs to poll for events from the <see cref="T:Disruptor.RingBuffer`1"/>
            using the appropriate wait strategy. It is unlikely that you will need to implement this interface yourself.
            Look at using the <see cref="T:Disruptor.IEventHandler`1"/> interface along with the pre-supplied BatchEventProcessor in the first
            instance.
            </summary>
        </member>
        <member name="P:Disruptor.IEventProcessor.Sequence">
            <summary>
            Return a reference to the <see cref="T:Disruptor.ISequence"/> being used by this <see cref="T:Disruptor.IEventProcessor"/>
            </summary>
        </member>
        <member name="M:Disruptor.IEventProcessor.Halt">
            <summary>
            Signal that this <see cref="T:Disruptor.IEventProcessor"/> should stop when it has finished consuming at the next clean break.
            It will call <see cref="M:Disruptor.ISequenceBarrier.Alert"/> to notify the thread to check status.
            </summary>
        </member>
        <member name="M:Disruptor.IEventProcessor.Run">
            <summary>
            Starts this instance 
            </summary>
        </member>
        <member name="P:Disruptor.IEventProcessor.IsRunning">
            <summary>
            Gets if the processor is running
            </summary>
        </member>
        <member name="T:Disruptor.IEventProcessorSequenceAware">
             <summary>
             Implement this interface in your event handler to obtain the <see cref="T:Disruptor.IEventProcessor"/> sequence.
            
             Used by the <see cref="T:Disruptor.IEventProcessor"/> to set a callback allowing the event handler to notify
             when it has finished consuming an event if this happens after the OnEvent call.
            
             Typically this would be used when the handler is performing some sort of batching operation such as writing to an IO
             device; after the operation has completed, the implementation should set <see cref="P:Disruptor.Sequence.Value"/> to update the
             sequence and allow other processes that are dependent on this handler to progress.
             </summary>
        </member>
        <member name="M:Disruptor.IEventProcessorSequenceAware.SetSequenceCallback(Disruptor.ISequence)">
            <summary>
            Call by the <see cref="T:Disruptor.IEventProcessor"/> to setup the callback.
            </summary>
            <param name="sequenceCallback">callback on which to notify the <see cref="T:Disruptor.IEventProcessor"/> that the sequence has progressed.</param>
        </member>
        <member name="T:Disruptor.IEventReleaseAware">
            <summary>
            Implement this interface in your <see cref="T:Disruptor.IWorkHandler`1"/> to obtain the <see cref="T:Disruptor.IEventReleaser"/>.
            </summary>
        </member>
        <member name="T:Disruptor.IExceptionHandler`1">
            <summary>
            Callback handler for uncaught exceptions in the event processing cycle of the <see cref="T:Disruptor.IBatchEventProcessor`1"/>
            </summary>
        </member>
        <member name="M:Disruptor.IExceptionHandler`1.HandleEventException(System.Exception,System.Int64,`0)">
            <summary>
            Strategy for handling uncaught exceptions when processing an event.
            
            If the strategy wishes to terminate further processing by the <see cref="T:Disruptor.IBatchEventProcessor`1"/>
            then it should throw a <see cref="T:System.ApplicationException"/>
            </summary>
            <param name="ex">exception that propagated from the <see cref="T:Disruptor.IEventHandler`1"/>.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
            <param name="evt">event being processed when the exception occurred. This can be null</param>
        </member>
        <member name="M:Disruptor.IExceptionHandler`1.HandleOnStartException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnStart"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
        </member>
        <member name="M:Disruptor.IExceptionHandler`1.HandleOnShutdownException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnShutdown"/>
            </summary>
            <param name="ex">ex throw during the shutdown process.</param>
        </member>
        <member name="T:Disruptor.IgnoreExceptionHandler">
            <summary>
            Convenience implementation of an exception handler that using Console.WriteLine to log the exception
            </summary>
        </member>
        <member name="M:Disruptor.IgnoreExceptionHandler.HandleEventException(System.Exception,System.Int64,System.Object)">
            <summary>
            Strategy for handling uncaught exceptions when processing an event.
            </summary>
            <param name="ex">exception that propagated from the <see cref="T:Disruptor.IEventHandler`1"/>.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
            <param name="evt">event being processed when the exception occurred.</param>
        </member>
        <member name="M:Disruptor.IgnoreExceptionHandler.HandleOnStartException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnStart"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
        </member>
        <member name="M:Disruptor.IgnoreExceptionHandler.HandleOnShutdownException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnShutdown"/>
            </summary>
            <param name="ex">ex throw during the shutdown process.</param>
        </member>
        <member name="T:Disruptor.ILifecycleAware">
            <summary>
            Implement this interface in your event handler to be notified when the processing thread starts and shuts down.
            </summary>
        </member>
        <member name="M:Disruptor.ILifecycleAware.OnStart">
            <summary>
             Called once on thread start before first event is available.
            </summary>
        </member>
        <member name="M:Disruptor.ILifecycleAware.OnShutdown">
             <summary>
             Called once just before the thread is shutdown.
            
             Sequence event processing will already have stopped before this method is called. No events will
             be processed after this message.
             </summary>
        </member>
        <member name="T:Disruptor.INonBlockingWaitStrategy">
            <summary>
            Marker interface for non-blocking <see cref="T:Disruptor.IWaitStrategy"/>.
            </summary>
        </member>
        <member name="P:Disruptor.ISequence.Value">
            <summary>
            Current sequence number
            </summary>
        </member>
        <member name="M:Disruptor.ISequence.SetValue(System.Int64)">
            <summary>
            Perform an ordered write of this sequence.  The intent is
            a Store/Store barrier between this write and any previous
            store.
            </summary>
            <param name="value">The new value for the sequence.</param>
        </member>
        <member name="M:Disruptor.ISequence.SetValueVolatile(System.Int64)">
            <summary>
            Performs a volatile write of this sequence.  The intent is a Store/Store barrier between this write and any previous
            write and a Store/Load barrier between this write and any subsequent volatile read. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Disruptor.ISequence.CompareAndSet(System.Int64,System.Int64)">
            <summary>
            Atomically set the value to the given updated value if the current value == the expected value.
            </summary>
            <param name="expectedSequence">the expected value for the sequence</param>
            <param name="nextSequence">the new value for the sequence</param>
            <returns>true if successful. False return indicates that the actual value was not equal to the expected value.</returns>
        </member>
        <member name="M:Disruptor.ISequence.IncrementAndGet">
            <summary>
             Increments the sequence and stores the result, as an atomic operation.
            </summary>
            <returns>incremented sequence</returns>
        </member>
        <member name="M:Disruptor.ISequence.AddAndGet(System.Int64)">
            <summary>
             Increments the sequence and stores the result, as an atomic operation.
            </summary>
            <returns>incremented sequence</returns>
        </member>
        <member name="T:Disruptor.ISequenceBarrier">
            <summary>
            Coordination barrier for tracking the cursor for producers and sequence of
            dependent <see cref="T:Disruptor.IEventProcessor"/>s for a <see cref="T:Disruptor.RingBuffer`1"/>
            </summary>
        </member>
        <member name="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)">
            <summary>
            Wait for the given sequence to be available for consumption.
            </summary>
            <param name="sequence">sequence to wait for</param>
            <returns>the sequence up to which is available</returns>
            <exception cref="T:Disruptor.AlertException">if a status change has occurred for the Disruptor</exception>
            <exception cref="T:Disruptor.TimeoutException">if a timeout occurs while waiting for the supplied sequence.</exception>
        </member>
        <member name="P:Disruptor.ISequenceBarrier.Cursor">
            <summary>
            Delegate a call to the <see cref="T:Disruptor.ISequencer"/>.
            Returns the value of the cursor for events that have been published.
            </summary>
        </member>
        <member name="P:Disruptor.ISequenceBarrier.IsAlerted">
            <summary>
            The current alert status for the barrier.
            Returns true if in alert otherwise false.
            </summary>
        </member>
        <member name="M:Disruptor.ISequenceBarrier.Alert">
            <summary>
             Alert the <see cref="T:Disruptor.IEventProcessor"/> of a status change and stay in this status until cleared.
            </summary>
        </member>
        <member name="M:Disruptor.ISequenceBarrier.ClearAlert">
            <summary>
            Clear the current alert status.
            </summary>
        </member>
        <member name="M:Disruptor.ISequenceBarrier.CheckAlert">
            <summary>
            Check if an alert has been raised and throw an <see cref="T:Disruptor.AlertException"/> if it has.
            </summary>
            <exception cref="T:Disruptor.AlertException">if alert has been raised.</exception>
        </member>
        <member name="P:Disruptor.ISequenced.BufferSize">
            <summary>
            Gets the capacity of the data structure to hold entries.
            </summary>
        </member>
        <member name="M:Disruptor.ISequenced.HasAvailableCapacity(System.Int32)">
            <summary>
            Has the buffer got capacity to allocate another sequence.  This is a concurrent
            method so the response should only be taken as an indication of available capacity.
            </summary>
            <param name="requiredCapacity">requiredCapacity in the buffer</param>
            <returns>true if the buffer has the capacity to allocate the next sequence otherwise false.</returns>
        </member>
        <member name="M:Disruptor.ISequenced.GetRemainingCapacity">
            <summary>
            Get the remaining capacity for this sequencer. return The number of slots remaining.
            </summary>
        </member>
        <member name="M:Disruptor.ISequenced.Next">
            <summary>
            Claim an available sequence in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequence afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.ISequenced.TryNext(System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            </remarks>
            <returns>The claimed sequence number.</returns>
        </member>
        <member name="M:Disruptor.ISequenced.Next(System.Int32)">
            <summary>
            Claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.ISequenced.TryNext(System.Int32,System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <returns>The sequence number of the highest slot claimed.</returns>
        </member>
        <member name="M:Disruptor.ISequenced.TryNext(System.Int64@)">
            <summary>
            Try to claim an available sequence in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequence afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will return false.
            </para>
            </remarks>
            <param name="sequence">the next sequence to publish to</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.ISequenced.TryNext(System.Int32,System.Int64@)">
            <summary>
            Try to claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will return false.
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <param name="sequence">sequence number of the highest slot claimed</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.ISequenced.Publish(System.Int64)">
            <summary>
            Publishes a sequence. Call when the event has been filled.
            </summary>
            <param name="sequence">the sequence to be published.</param>
        </member>
        <member name="M:Disruptor.ISequenced.Publish(System.Int64,System.Int64)">
            <summary>
            Batch publish sequences.  Called when all of the events have been filled.
            </summary>
            <param name="lo">first sequence number to publish</param>
            <param name="hi">last sequence number to publish</param>
        </member>
        <member name="T:Disruptor.ISequencer">
            <summary>
            Coordinator for claiming sequences for access to a data structure while tracking dependent <see cref="T:Disruptor.Sequence"/>s
            </summary>
        </member>
        <member name="M:Disruptor.ISequencer.Claim(System.Int64)">
            <summary>
            Claim a specific sequence when only one publisher is involved.
            </summary>
            <param name="sequence">sequence to be claimed.</param>
        </member>
        <member name="M:Disruptor.ISequencer.IsAvailable(System.Int64)">
            <summary>
            Confirms if a sequence is published and the event is available for use; non-blocking.
            </summary>
            <param name="sequence">sequence of the buffer to check</param>
            <returns>true if the sequence is available for use, false if not</returns>
        </member>
        <member name="M:Disruptor.ISequencer.AddGatingSequences(Disruptor.ISequence[])">
            <summary>
            Add the specified gating sequences to this instance of the Disruptor.  They will
            safely and atomically added to the list of gating sequences.
            </summary>
            <param name="gatingSequences">The sequences to add.</param>
        </member>
        <member name="M:Disruptor.ISequencer.RemoveGatingSequence(Disruptor.ISequence)">
            <summary>
            Remove the specified sequence from this sequencer.
            </summary>
            <param name="sequence">to be removed.</param>
            <returns>true if this sequence was found, false otherwise.</returns>
        </member>
        <member name="M:Disruptor.ISequencer.NewBarrier(Disruptor.ISequence[])">
            <summary>
            Create a <see cref="T:Disruptor.ISequenceBarrier"/> that gates on the the cursor and a list of <see cref="T:Disruptor.Sequence"/>s
            </summary>
            <param name="sequencesToTrack">All of the sequences that the newly constructed barrier will wait on.</param>
            <returns>A sequence barrier that will track the specified sequences.</returns>
        </member>
        <member name="M:Disruptor.ISequencer.GetMinimumSequence">
            <summary>
            Get the minimum sequence value from all of the gating sequences
            added to this ringBuffer.
            </summary>
            <returns>The minimum gating sequence or the cursor sequence if no sequences have been added.</returns>
        </member>
        <member name="M:Disruptor.ISequencer.GetHighestPublishedSequence(System.Int64,System.Int64)">
            <summary>
            Get the highest sequence number that can be safely read from the ring buffer.  Depending
            on the implementation of the Sequencer this call may need to scan a number of values
            in the Sequencer.  The scan will range from nextSequence to availableSequence.  If
            there are no available values <code>>= nextSequence</code> the return value will be
            <code>nextSequence - 1</code>.  To work correctly a consumer should pass a value that
            it 1 higher than the last sequence that was successfully processed.
            </summary>
            <param name="nextSequence">The sequence to start scanning from.</param>
            <param name="availableSequence">The sequence to scan to.</param>
            <returns>The highest value that can be safely read, will be at least <code>nextSequence - 1</code>.</returns>
        </member>
        <member name="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            Creates an event poller for this sequence that will use the supplied data provider and
            gating sequences.
            </summary>
        </member>
        <member name="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            Creates an event poller for this sequence that will use the supplied data provider and
            gating sequences.
            </summary>
        </member>
        <member name="T:Disruptor.ISequenceReportingEventHandler`1">
             <summary>
             Used by the <see cref="T:Disruptor.IBatchEventProcessor`1"/> to set a callback allowing the <see cref="T:Disruptor.IEventHandler`1"/> to notify
             when it has finished consuming an event if this happens after the <see cref="M:Disruptor.IEventHandler`1.OnEvent(`0,System.Int64,System.Boolean)"/> call.
            
             Typically this would be used when the handler is performing some sort of batching operation such as writing to an IO
             device; after the operation has completed, the implementation should set <see cref="P:Disruptor.Sequence.Value"/> to update the
             sequence and allow other processes that are dependent on this handler to progress.
             </summary>
             <typeparam name="T">event implementation storing the data for sharing during exchange or parallel coordination of an event.</typeparam>
        </member>
        <member name="T:Disruptor.IValueBatchEventProcessor`1">
            <summary>
            Interface for <see cref="T:Disruptor.ValueBatchEventProcessor`5"/>.
            </summary>
            <typeparam name="T">the type of event used.</typeparam>
        </member>
        <member name="M:Disruptor.IValueBatchEventProcessor`1.WaitUntilStarted(System.TimeSpan)">
            <summary>
            Waits before the event processor enters the <see cref="P:Disruptor.IEventProcessor.IsRunning"/> state.
            </summary>
            <param name="timeout">maximum wait duration</param>
        </member>
        <member name="M:Disruptor.IValueBatchEventProcessor`1.SetExceptionHandler(Disruptor.IValueExceptionHandler{`0})">
            <summary>
            Set a new <see cref="T:Disruptor.IValueExceptionHandler`1"/> for handling exceptions propagated out of the <see cref="T:Disruptor.IEventHandler`1"/>
            </summary>
            <param name="exceptionHandler">exceptionHandler to replace the existing exceptionHandler.</param>
        </member>
        <member name="T:Disruptor.IValueEventHandler`1">
            <summary>
            Callback interface to be implemented for processing events as they become available in the <see cref="T:Disruptor.ValueRingBuffer`1"/>
            </summary>
            <typeparam name="T">Type of events for sharing during exchange or parallel coordination of an event.</typeparam>
            <remarks>See <see cref="M:Disruptor.IValueBatchEventProcessor`1.SetExceptionHandler(Disruptor.IValueExceptionHandler{`0})"/> if you want to handle exceptions propagated out of the handler.</remarks>
        </member>
        <member name="M:Disruptor.IValueEventHandler`1.OnEvent(`0@,System.Int64,System.Boolean)">
            <summary>
            Called when a publisher has committed an event to the <see cref="T:Disruptor.ValueRingBuffer`1"/>. The <see cref="T:Disruptor.IValueBatchEventProcessor`1"/> will
            read messages from the <see cref="T:Disruptor.ValueRingBuffer`1"/> in batches, where a batch is all of the events available to be
            processed without having to wait for any new event to arrive.  This can be useful for event handlers that need
            to do slower operations like I/O as they can group together the data from multiple events into a single
            operation.  Implementations should ensure that the operation is always performed when endOfBatch is true as
            the time between that message an the next one is indeterminate.
            </summary>
            <param name="data">Data committed to the <see cref="T:Disruptor.ValueRingBuffer`1"/></param>
            <param name="sequence">Sequence number committed to the <see cref="T:Disruptor.ValueRingBuffer`1"/></param>
            <param name="endOfBatch">flag to indicate if this is the last event in a batch from the <see cref="T:Disruptor.ValueRingBuffer`1"/></param>
        </member>
        <member name="T:Disruptor.IValueExceptionHandler`1">
            <summary>
            Callback handler for uncaught exceptions in the event processing cycle of the <see cref="T:Disruptor.IValueBatchEventProcessor`1"/>
            </summary>
        </member>
        <member name="M:Disruptor.IValueExceptionHandler`1.HandleEventException(System.Exception,System.Int64,`0@)">
            <summary>
            Strategy for handling uncaught exceptions when processing an event.
            
            If the strategy wishes to terminate further processing by the <see cref="T:Disruptor.IValueBatchEventProcessor`1"/>
            then it should throw a <see cref="T:System.ApplicationException"/>
            </summary>
            <param name="ex">exception that propagated from the <see cref="T:Disruptor.IValueEventHandler`1"/>.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
            <param name="evt">event being processed when the exception occurred. This can be null</param>
        </member>
        <member name="M:Disruptor.IValueExceptionHandler`1.HandleOnTimeoutException(System.Exception,System.Int64)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ITimeoutHandler.OnTimeout(System.Int64)"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
        </member>
        <member name="M:Disruptor.IValueExceptionHandler`1.HandleOnStartException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnStart"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
        </member>
        <member name="M:Disruptor.IValueExceptionHandler`1.HandleOnShutdownException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnShutdown"/>
            </summary>
            <param name="ex">ex throw during the shutdown process.</param>
        </member>
        <member name="T:Disruptor.IWaitStrategy">
            <summary>
            Strategy employed for making <see cref="T:Disruptor.IEventProcessor"/>s wait on a <see cref="T:Disruptor.RingBuffer`1"/>.
            </summary>
        </member>
        <member name="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            Wait for the given sequence to be available.  It is possible for this method to return a value
            less than the sequence number supplied depending on the implementation of the WaitStrategy.A common
            use for this is to signal a timeout.Any EventProcessor that is using a WaitStrategy to get notifications
            about message becoming available should remember to handle this case.  The <see cref="T:Disruptor.IBatchEventProcessor`1"/>
            explicitly handles this case and will signal a timeout if required.
            </summary>
            <param name="sequence">sequence to be waited on.</param>
            <param name="cursor">Ring buffer cursor on which to wait.</param>
            <param name="dependentSequence">on which to wait.</param>
            <param name="barrier">barrier the <see cref="T:Disruptor.IEventProcessor"/> is waiting on.</param>
            <returns>the sequence that is available which may be greater than the requested sequence.</returns>
            <exception cref="T:Disruptor.TimeoutException">if a timeout occurs before waiting completes (not used by some strategies)</exception>
        </member>
        <member name="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking">
            <summary>
            Signal those <see cref="T:Disruptor.IEventProcessor"/> waiting that the cursor has advanced.
            </summary>
        </member>
        <member name="T:Disruptor.IWorkHandler`1">
            <summary>
            Callback interface to be implemented for processing units of work as they become available in the <see cref="T:Disruptor.RingBuffer`1"/>
            
            </summary>
            <typeparam name="T">event implementation storing the data for sharing during exchange or parallel coordination of an event.</typeparam>
        </member>
        <member name="M:Disruptor.IWorkHandler`1.OnEvent(`0)">
            <summary>
            Callback to indicate a unit of work needs to be processed.
            </summary>
            <param name="evt">event published to the <see cref="T:Disruptor.RingBuffer`1"/></param>
        </member>
        <member name="T:Disruptor.LiteTimeoutBlockingWaitStrategy">
            <summary>
            Variation of the <see cref="T:Disruptor.TimeoutBlockingWaitStrategy"/> that attempts to elide conditional wake-ups
            when the lock is uncontended.
            </summary>
        </member>
        <member name="M:Disruptor.LiteTimeoutBlockingWaitStrategy.#ctor(System.TimeSpan)">
            <summary>
            Creates a <see cref="T:Disruptor.LiteTimeoutBlockingWaitStrategy"/> with the specified timeout.
            </summary>
        </member>
        <member name="M:Disruptor.LiteTimeoutBlockingWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.LiteTimeoutBlockingWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>.
            </summary>
        </member>
        <member name="T:Disruptor.MultiProducerSequencer">
            <summary>
            <para>Coordinator for claiming sequences for access to a data structure while tracking dependent <see cref="T:Disruptor.Sequence"/>s.
            Suitable for use for sequencing across multiple publisher threads.</para>
            <para/>
            <para/>Note on <see cref="P:Disruptor.ICursored.Cursor"/>:  With this sequencer the cursor value is updated after the call
            to <see cref="M:Disruptor.ISequenced.Next"/>, to determine the highest available sequence that can be read, then
            <see cref="M:Disruptor.MultiProducerSequencer.GetHighestPublishedSequence(System.Int64,System.Int64)"/> should be used.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.NewBarrier(Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewBarrier(Disruptor.ISequence[])"/>
            </summary>
        </member>
        <member name="P:Disruptor.MultiProducerSequencer.BufferSize">
            <summary>
            <see cref="P:Disruptor.ISequenced.BufferSize"/>.
            </summary>
        </member>
        <member name="P:Disruptor.MultiProducerSequencer.Cursor">
            <summary>
            <see cref="P:Disruptor.ICursored.Cursor"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.HasAvailableCapacity(System.Int32)">
            <summary>
            <see cref="M:Disruptor.ISequenced.HasAvailableCapacity(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.Claim(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.Claim(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.Next">
            <summary>
            <see cref="M:Disruptor.ISequenced.Next"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.Next(System.Int32)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Next(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.TryNext(System.Int64@)">
            <summary>
            <see cref="M:Disruptor.ISequenced.TryNext(System.Int64@)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.TryNext(System.Int32,System.Int64@)">
            <summary>
            <see cref="M:Disruptor.ISequenced.TryNext(System.Int32,System.Int64@)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.GetRemainingCapacity">
            <summary>
            <see cref="M:Disruptor.ISequenced.GetRemainingCapacity"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.Publish(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Publish(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.Publish(System.Int64,System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Publish(System.Int64,System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.IsAvailable(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.IsAvailable(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.GetHighestPublishedSequence(System.Int64,System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.GetHighestPublishedSequence(System.Int64,System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.AddGatingSequences(Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.AddGatingSequences(Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.RemoveGatingSequence(Disruptor.ISequence)">
            <summary>
            <see cref="M:Disruptor.ISequencer.RemoveGatingSequence(Disruptor.ISequence)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.GetMinimumSequence">
            <summary>
            <see cref="M:Disruptor.ISequencer.GetMinimumSequence"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.NewPoller``1(Disruptor.IDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IDataProvider{``0},Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="M:Disruptor.MultiProducerSequencer.NewPoller``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="T:Disruptor.NoOpEventProcessor`1">
            <summary>
            No operation version of a <see cref="T:Disruptor.IEventProcessor"/> that simply tracks a <see cref="T:Disruptor.Sequence"/>.
            This is useful in tests or for pre-filling a <see cref="T:Disruptor.RingBuffer`1"/> from a producer.
            </summary>
        </member>
        <member name="M:Disruptor.NoOpEventProcessor`1.#ctor(Disruptor.ICursored)">
            <summary>
            Construct a <see cref="T:Disruptor.IEventProcessor"/> that simply tracks a <see cref="T:Disruptor.Sequence"/>.
            </summary>
            <param name="sequencer">sequencer to track.</param>
        </member>
        <member name="M:Disruptor.NoOpEventProcessor`1.Run">
            <summary>
            NoOp
            </summary>
        </member>
        <member name="P:Disruptor.NoOpEventProcessor`1.Sequence">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.Sequence"/>
            </summary>
        </member>
        <member name="M:Disruptor.NoOpEventProcessor`1.Halt">
            <summary>
            NoOp
            </summary>
        </member>
        <member name="P:Disruptor.NoOpEventProcessor`1.IsRunning">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.IsRunning"/>
            </summary>
        </member>
        <member name="T:Disruptor.PhasedBackoffWaitStrategy">
            <summary>
            <para>Phased wait strategy for waiting <see cref="T:Disruptor.IEventProcessor"/>s on a barrier.</para>
            
            <para>This strategy can be used when throughput and low-latency are not as important as CPU resource.
            Spins, then yields, then waits using the configured fallback WaitStrategy.</para>
            </summary>
        </member>
        <member name="M:Disruptor.PhasedBackoffWaitStrategy.WithLock(System.TimeSpan,System.TimeSpan)">
            <summary>
            Construct <see cref="T:Disruptor.PhasedBackoffWaitStrategy"/> with fallback to <see cref="T:Disruptor.BlockingWaitStrategy"/>
            </summary>
            <param name="spinTimeout">The maximum time in to busy spin for.</param>
            <param name="yieldTimeout">The maximum time in to yield for.</param>
            <returns>The constructed wait strategy.</returns>
        </member>
        <member name="M:Disruptor.PhasedBackoffWaitStrategy.WithSleep(System.TimeSpan,System.TimeSpan)">
            <summary>
            Construct <see cref="T:Disruptor.PhasedBackoffWaitStrategy"/> with fallback to <see cref="T:Disruptor.SleepingWaitStrategy"/>
            </summary>
            <param name="spinTimeout">The maximum time in to busy spin for.</param>
            <param name="yieldTimeout">The maximum time in to yield for.</param>
            <returns>The constructed wait strategy.</returns>
        </member>
        <member name="M:Disruptor.PhasedBackoffWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.PhasedBackoffWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.ProcessingSequenceBarrier`2">
            <summary>
            <see cref="T:Disruptor.ISequenceBarrier"/> handed out for gating <see cref="T:Disruptor.IEventProcessor"/> on a cursor sequence and optional dependent <see cref="T:Disruptor.IEventProcessor"/>s,
             using the given WaitStrategy.
            </summary>
            <typeparam name="TSequencer">the type of the <see cref="T:Disruptor.ISequencer"/> used.</typeparam>
            <typeparam name="TWaitStrategy">the type of the <see cref="T:Disruptor.IWaitStrategy"/> used.</typeparam>
        </member>
        <member name="T:Disruptor.ProcessingSequenceBarrierFactory">
            <summary>
            Factory that creates optimized instance of <see cref="T:Disruptor.ProcessingSequenceBarrier`2"/>.
            </summary>
        </member>
        <member name="M:Disruptor.ProcessingSequenceBarrierFactory.Create(Disruptor.ISequencer,Disruptor.IWaitStrategy,Disruptor.Sequence,Disruptor.ISequence[])">
            <summary>
            Create a new <see cref="T:Disruptor.ProcessingSequenceBarrier`2"/> with dedicated generic arguments.
            </summary>
        </member>
        <member name="T:Disruptor.ReadOnlySequenceGroup">
            <summary>
            Hides a group of Sequences behind a single Sequence
            </summary>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.#ctor(Disruptor.ISequence[])">
            <summary> </summary>
            <param name="sequences">sequences the list of sequences to be tracked under this sequence group</param>
        </member>
        <member name="P:Disruptor.ReadOnlySequenceGroup.Value">
            <summary>
            Get the minimum sequence value for the group.
            </summary>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.SetValue(System.Int64)">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.SetValueVolatile(System.Int64)">
            <summary>
            Not supported
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.CompareAndSet(System.Int64,System.Int64)">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.IncrementAndGet">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="M:Disruptor.ReadOnlySequenceGroup.AddAndGet(System.Int64)">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer">
             <summary>
             Base type for array-backed ring buffers.
            
             <see cref="T:Disruptor.RingBuffer`1"/> and <see cref="T:Disruptor.ValueRingBuffer`1"/>.
             </summary>
        </member>
        <member name="M:Disruptor.RingBuffer.#ctor(Disruptor.ISequencer,System.Type,System.Int32)">
            <summary>
            Construct a RingBuffer with the full option set.
            </summary>
            <param name="sequencer">sequencer to handle the ordering of events moving through the RingBuffer.</param>
            <param name="eventType">type of ring buffer events</param>
            <param name="bufferPad">ring buffer padding  as a number of events</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="P:Disruptor.RingBuffer.BufferSize">
            <summary>
            Gets the size of the buffer.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer.HasAvailableCapacity(System.Int32)">
            <summary>
            Given specified <paramref name="requiredCapacity"/> determines if that amount of space
            is available.  Note, you can not assume that if this method returns <c>true</c>
            that a call to <see cref="M:Disruptor.RingBuffer.Next"/> will not block.  Especially true if this
            ring buffer is set up to handle multiple producers.
            </summary>
            <param name="requiredCapacity">The capacity to check for.</param>
            <returns><c>true</c> if the specified <paramref name="requiredCapacity"/> is available <c>false</c> if not.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.Next">
            <summary>
            Claim an available sequence in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequence afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.RingBuffer.TryNext(System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            long sequence = ringBuffer.Next();
            try
            {
                // Do some work with ringBuffer[sequence];
            }
            finally
            {
                ringBuffer.Publish(sequence);
            }
            </code>
            </para>
            </remarks>
            <returns>The claimed sequence number.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.Next(System.Int32)">
            <summary>
            Claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.RingBuffer.TryNext(System.Int32,System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            long hi = ringBuffer.Next(_batchSize);
            long lo = hi - _batchSize + 1;
            try
            {
                for (long s = lo; s &lt;= hi; s++)
                {
                    // Do some work with ringBuffer[s];
                }
            }
            finally
            {
                ringBuffer.Publish(lo, hi);
            }
            </code>
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <returns>The sequence number of the highest slot claimed.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.TryNext(System.Int64@)">
            <summary>
            Try to claim an available sequence in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequence afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will return false.
            </para>
            <para>
            Example:
            <code>
            if (!ringBuffer.TryNext(out var sequence))
            {
                // Handle full ring buffer
                return;
            }
            try
            {
                // Do some work with ringBuffer[sequence];
            }
            finally
            {
                ringBuffer.Publish(sequence);
            }
            </code>
            </para>
            </remarks>
            <param name="sequence">the next sequence to publish to</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.TryNext(System.Int32,System.Int64@)">
            <summary>
            Try to claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will return false.
            </para>
            <para>
            Example:
            <code>
            if (!ringBuffer.TryNext(_batchSize, out var hi))
            {
                // Handle full ring buffer
                return;
            }
            long lo = hi - _batchSize + 1;
            try
            {
                for (long s = lo; s &lt;= hi; s++)
                {
                    // Do some work with ringBuffer[s];
                }
            }
            finally
            {
                ringBuffer.Publish(lo, hi);
            }
            </code>
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <param name="sequence">sequence number of the highest slot claimed</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.ResetTo(System.Int64)">
            <summary>
            Resets the cursor to a specific value.  This can be applied at any time, but it is worth noting
            that it can cause a data race and should only be used in controlled circumstances.  E.g. during
            initialisation.
            </summary>
            <param name="sequence">the sequence to reset too.</param>
        </member>
        <member name="M:Disruptor.RingBuffer.AddGatingSequences(Disruptor.ISequence[])">
            <summary>
            Add the specified gating sequences to this instance of the Disruptor.  They will
            safely and atomically added to the list of gating sequences.
            </summary>
            <param name="gatingSequences">the sequences to add.</param>
        </member>
        <member name="M:Disruptor.RingBuffer.GetMinimumGatingSequence">
            <summary>
            Get the minimum sequence value from all of the gating sequences
            added to this ringBuffer.
            </summary>
            <returns>the minimum gating sequence or the cursor sequence if no sequences have been added.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.RemoveGatingSequence(Disruptor.ISequence)">
            <summary>
            Remove the specified sequence from this ringBuffer.
            </summary>
            <param name="sequence">sequence to be removed.</param>
            <returns><c>true</c> if this sequence was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer.NewBarrier(Disruptor.ISequence[])">
            <summary>
            Create a new SequenceBarrier to be used by an EventProcessor to track which messages
            are available to be read from the ring buffer given a list of sequences to track.
            </summary>
            <param name="sequencesToTrack">the additional sequences to track</param>
            <returns>A sequence barrier that will track the specified sequences.</returns>
        </member>
        <member name="P:Disruptor.RingBuffer.Cursor">
            <summary>
            Get the current cursor value for the ring buffer.  The actual value received
            will depend on the type of <see cref="T:Disruptor.ISequencer"/> that is being used.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer.Publish(System.Int64)">
            <summary>
            Publish the specified sequence.  This action marks this particular
            message as being available to be read.
            </summary>
            <param name="sequence">the sequence to publish.</param>
        </member>
        <member name="M:Disruptor.RingBuffer.Publish(System.Int64,System.Int64)">
            <summary>
            Publish the specified sequences.  This action marks these particular
            messages as being available to be read.
            </summary>
            <param name="lo">the lowest sequence number to be published</param>
            <param name="hi">the highest sequence number to be published</param>
        </member>
        <member name="M:Disruptor.RingBuffer.GetRemainingCapacity">
            <summary>
            Get the remaining capacity for this ringBuffer.
            </summary>
            <returns>The number of slots remaining.</returns>
        </member>
        <member name="T:Disruptor.RingBuffer`1">
            <summary>
            Ring based store of reusable entries containing the data representing
            an event being exchanged between event producer and <see cref="T:Disruptor.IEventProcessor"/>s.
            </summary>
            <typeparam name="T">implementation storing the data for sharing during exchange or parallel coordination of an event.</typeparam>
        </member>
        <member name="M:Disruptor.RingBuffer`1.#ctor(System.Func{`0},Disruptor.ISequencer)">
            <summary>
            Construct a RingBuffer with the full option set.
            </summary>
            <param name="eventFactory">eventFactory to create entries for filling the RingBuffer</param>
            <param name="sequencer">sequencer to handle the ordering of events moving through the RingBuffer.</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.RingBuffer`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            Construct a RingBuffer with a <see cref="T:Disruptor.MultiProducerSequencer"/> sequencer.
            </summary>
            <param name="eventFactory"> eventFactory to create entries for filling the RingBuffer</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
        </member>
        <member name="M:Disruptor.RingBuffer`1.CreateMultiProducer(System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new multiple producer RingBuffer with the specified wait strategy.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.RingBuffer`1.CreateMultiProducer(System.Func{`0},System.Int32)">
            <summary>
            Create a new multiple producer RingBuffer using the default wait strategy <see cref="T:Disruptor.BlockingWaitStrategy"/>.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.RingBuffer`1.CreateSingleProducer(System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new single producer RingBuffer with the specified wait strategy.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.RingBuffer`1.CreateSingleProducer(System.Func{`0},System.Int32)">
            <summary>
            Create a new single producer RingBuffer using the default wait strategy <see cref="T:Disruptor.BlockingWaitStrategy"/>.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.RingBuffer`1.Create(Disruptor.Dsl.ProducerType,System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new Ring Buffer with the specified producer type (SINGLE or MULTI)
            </summary>
            <param name="producerType">producer type to use <see cref="T:Disruptor.Dsl.ProducerType" /></param>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the producer type is invalid</exception>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="P:Disruptor.RingBuffer`1.Item(System.Int64)">
             <summary>
             Get the event for a given sequence in the RingBuffer.
            
             This call has 2 uses.  Firstly use this call when publishing to a ring buffer.
             After calling <see cref="M:Disruptor.RingBuffer.Next"/> use this call to get hold of the
             preallocated event to fill with data before calling <see cref="M:Disruptor.RingBuffer.Publish(System.Int64)"/>.
            
             Secondly use this call when consuming data from the ring buffer.  After calling
             <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> call this method with any value greater than
             that your current consumer sequence and less than or equal to the value returned from
             the <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> method.
             </summary>
             <param name="sequence">sequence for the event</param>
             <returns>the event for the given sequence</returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.ClaimAndGetPreallocated(System.Int64)">
            <summary>
            Sets the cursor to a specific sequence and returns the preallocated entry that is stored there.  This
            can cause a data race and should only be done in controlled circumstances, e.g. during initialisation.
            </summary>
            <param name="sequence">the sequence to claim.</param>
            <returns>the preallocated event.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.IsPublished(System.Int64)">
            <summary>
            Determines if a particular entry is available.  Note that using this when not within a context that is
            maintaining a sequence barrier, it is likely that using this to determine if you can read a value is likely
            to result in a race condition and broken code.
            </summary>
            <param name="sequence">The sequence to identify the entry.</param>
            <returns><c>true</c> if the value can be read, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.NewPoller(Disruptor.ISequence[])">
            <summary>
            Creates an event poller for this ring buffer gated on the supplied sequences.
            </summary>
            <param name="gatingSequences">gatingSequences to be gated on.</param>
            <returns>A poller that will gate on this ring buffer and the supplied sequences.</returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.PublishEvent">
            <summary>
            Increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.RingBuffer`1.TryPublishEvent"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvent())
            {
                var e = scope.Event();
                // Do some work with the event.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.RingBuffer`1.TryPublishEvent">
             <summary>
             Try to increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block if there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent())
             {
                 if (!scope.TryGetEvent(out var eventRef))
                     return;
            
                 var e = eventRef.Event();
                 // Do some work with the event.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:Disruptor.RingBuffer`1.PublishEvents(System.Int32)">
            <summary>
            Increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.RingBuffer`1.TryPublishEvents(System.Int32)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvents(2))
            {
                var e1 = scope.Event(0);
                var e2 = scope.Event(1);
                // Do some work with the events.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.RingBuffer`1.TryPublishEvents(System.Int32)">
             <summary>
             Try to increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block when there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent(2))
             {
                 if (!scope.TryGetEvents(out var eventsRef))
                     return;
            
                 var e1 = eventRefs.Event(0);
                 var e2 = eventRefs.Event(1);
                 // Do some work with the events.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="T:Disruptor.RingBuffer`1.UnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.UnpublishedEventScope.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.UnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer`1.UnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.UnpublishedEventBatchScope.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.UnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence number batch.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer`1.NullableUnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.RingBuffer`1.NullableUnpublishedEventScope.HasEvent">
            <summary>
            Returns a value indicating whether the sequence was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.NullableUnpublishedEventScope.TryGetEvent(Disruptor.RingBuffer{`0}.EventRef@)">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
            <returns>
            true if the sequence number was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.NullableUnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer`1.EventRef">
            <summary>
            Holds an unpublished sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.EventRef.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer`1.NullableUnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.RingBuffer`1.NullableUnpublishedEventBatchScope.HasEvents">
            <summary>
            Returns a value indicating whether the sequence batch was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.NullableUnpublishedEventBatchScope.TryGetEvents(Disruptor.RingBuffer{`0}.EventBatchRef@)">
            <summary>
            Gets the events for the associated sequence number batch.
            </summary>
            <returns>
            true if the sequence batch was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.RingBuffer`1.NullableUnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence batch if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.RingBuffer`1.EventBatchRef">
            <summary>
            Holds an unpublished sequence number batch.
            </summary>
        </member>
        <member name="M:Disruptor.RingBuffer`1.EventBatchRef.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="T:Disruptor.Sequence">
             <summary>
             <p>Concurrent sequence class used for tracking the progress of
             the ring buffer and event processors.Support a number
             of concurrent operations including CAS and order writes.</p>
            
             <p>Also attempts to be more efficient with regards to false
             sharing by adding padding around the volatile field.</p>
             </summary>
        </member>
        <member name="F:Disruptor.Sequence.InitialCursorValue">
            <summary>
            Set to -1 as sequence starting point
            </summary>
        </member>
        <member name="M:Disruptor.Sequence.#ctor(System.Int64)">
            <summary>
            Construct a new sequence counter that can be tracked across threads.
            </summary>
            <param name="initialValue">initial value for the counter</param>
        </member>
        <member name="P:Disruptor.Sequence.Value">
            <summary>
            Current sequence number
            </summary>
        </member>
        <member name="M:Disruptor.Sequence.SetValue(System.Int64)">
            <summary>
            Perform an ordered write of this sequence.  The intent is
            a Store/Store barrier between this write and any previous
            store.
            </summary>
            <param name="value">The new value for the sequence.</param>
        </member>
        <member name="M:Disruptor.Sequence.SetValueVolatile(System.Int64)">
            <summary>
            Performs a volatile write of this sequence.  The intent is a Store/Store barrier between this write and any previous
            write and a Store/Load barrier between this write and any subsequent volatile read. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Disruptor.Sequence.CompareAndSet(System.Int64,System.Int64)">
            <summary>
            Atomically set the value to the given updated value if the current value == the expected value.
            </summary>
            <param name="expectedSequence">the expected value for the sequence</param>
            <param name="nextSequence">the new value for the sequence</param>
            <returns>true if successful. False return indicates that the actual value was not equal to the expected value.</returns>
        </member>
        <member name="M:Disruptor.Sequence.ToString">
            <summary>
            Value of the <see cref="T:Disruptor.Sequence"/> as a String.
            </summary>
            <returns>String representation of the sequence.</returns>
        </member>
        <member name="M:Disruptor.Sequence.IncrementAndGet">
            <summary>
             Increments the sequence and stores the result, as an atomic operation.
            </summary>
            <returns>incremented sequence</returns>
        </member>
        <member name="M:Disruptor.Sequence.AddAndGet(System.Int64)">
            <summary>
             Increments the sequence and stores the result, as an atomic operation.
            </summary>
            <returns>incremented sequence</returns>
        </member>
        <member name="T:Disruptor.SequenceGroup">
            <summary>
            A <see cref="T:Disruptor.Sequence"/> group that can dynamically have <see cref="T:Disruptor.Sequence"/>s added and removed while being
            thread safe.
            
            The <see cref="P:Disruptor.SequenceGroup.Value"/> get and set methods are lock free and can be
            concurrently called with the <see cref="M:Disruptor.SequenceGroup.Add(Disruptor.ISequence)"/> and <see cref="M:Disruptor.SequenceGroup.Remove(Disruptor.ISequence)"/>.
            </summary>
        </member>
        <member name="F:Disruptor.SequenceGroup._sequences">
            <summary>Volatile in the Java version => always use Volatile.Read/Write or Interlocked methods to access this field.</summary>
        </member>
        <member name="P:Disruptor.SequenceGroup.Value">
            <summary>
            Get the minimum sequence value for the group.
            </summary>
        </member>
        <member name="M:Disruptor.SequenceGroup.SetValue(System.Int64)">
            <summary>
            Set all <see cref="T:Disruptor.Sequence"/>s in the group to a given value.
            </summary>
            <param name="value">value to set the group of sequences to.</param>
        </member>
        <member name="M:Disruptor.SequenceGroup.SetValueVolatile(System.Int64)">
            <summary>
            Performs a volatile write of this sequence.  The intent is a Store/Store barrier between this write and any previous
            write and a Store/Load barrier between this write and any subsequent volatile read. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Disruptor.SequenceGroup.Add(Disruptor.ISequence)">
            <summary>
            Add a <see cref="T:Disruptor.Sequence"/> into this aggregate. This should only be used during
            initialisation. Use <see cref="M:Disruptor.SequenceGroup.AddWhileRunning(Disruptor.ICursored,Disruptor.Sequence)"/>.
            </summary>
            <param name="sequence">sequence to be added to the aggregate.</param>
        </member>
        <member name="M:Disruptor.SequenceGroup.Remove(Disruptor.ISequence)">
            <summary>
            Remove the first occurrence of the <see cref="T:Disruptor.Sequence"/> from this aggregate.
            </summary>
            <param name="sequence">sequence to be removed from this aggregate.</param>
            <returns>true if the sequence was removed otherwise false.</returns>
        </member>
        <member name="P:Disruptor.SequenceGroup.Size">
            <summary>
            Get the size of the group.
            </summary>
        </member>
        <member name="M:Disruptor.SequenceGroup.AddWhileRunning(Disruptor.ICursored,Disruptor.Sequence)">
            <summary>
            Adds a sequence to the sequence group after threads have started to publish to
            the Disruptor.It will set the sequences to cursor value of the ringBuffer
            just after adding them.  This should prevent any nasty rewind/wrapping effects.
            </summary>
            <param name="cursored">The data structure that the owner of this sequence group will be pulling it's events from</param>
            <param name="sequence">The sequence to add</param>
        </member>
        <member name="T:Disruptor.SequenceGroups">
            <summary>
            Provides static methods for managing groups of <see cref="T:Disruptor.ISequence"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.NewBarrier(Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewBarrier(Disruptor.ISequence[])"/>
            </summary>
        </member>
        <member name="P:Disruptor.SingleProducerSequencer.BufferSize">
            <summary>
            <see cref="P:Disruptor.ISequenced.BufferSize"/>.
            </summary>
        </member>
        <member name="P:Disruptor.SingleProducerSequencer.Cursor">
            <summary>
            <see cref="P:Disruptor.ICursored.Cursor"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.HasAvailableCapacity(System.Int32)">
            <summary>
            <see cref="M:Disruptor.ISequenced.HasAvailableCapacity(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.Next">
            <summary>
            <see cref="M:Disruptor.ISequenced.Next"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.Next(System.Int32)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Next(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.TryNext(System.Int64@)">
            <summary>
            <see cref="M:Disruptor.ISequenced.TryNext(System.Int64@)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.TryNext(System.Int32,System.Int64@)">
            <summary>
            <see cref="M:Disruptor.ISequenced.TryNext(System.Int32,System.Int64@)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.GetRemainingCapacity">
            <summary>
            <see cref="M:Disruptor.ISequenced.GetRemainingCapacity"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.Claim(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.Claim(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.Publish(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Publish(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.Publish(System.Int64,System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequenced.Publish(System.Int64,System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.IsAvailable(System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.IsAvailable(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.GetHighestPublishedSequence(System.Int64,System.Int64)">
            <summary>
            <see cref="M:Disruptor.ISequencer.GetHighestPublishedSequence(System.Int64,System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.AddGatingSequences(Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.AddGatingSequences(Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.RemoveGatingSequence(Disruptor.ISequence)">
            <summary>
            <see cref="M:Disruptor.ISequencer.RemoveGatingSequence(Disruptor.ISequence)"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.GetMinimumSequence">
            <summary>
            <see cref="M:Disruptor.ISequencer.GetMinimumSequence"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.NewPoller``1(Disruptor.IDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IDataProvider{``0},Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="M:Disruptor.SingleProducerSequencer.NewPoller``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequence[])">
            <summary>
            <see cref="M:Disruptor.ISequencer.NewPoller``1(Disruptor.IValueDataProvider{``0},Disruptor.ISequence[])"/>.
            </summary>
        </member>
        <member name="T:Disruptor.SleepingWaitStrategy">
            <summary>
            Sleeping strategy that initially spins, then uses a Thread.Yield(), and
            eventually sleep(<code>Thread.Sleep(0)</code>) for the minimum
            number of nanos the OS and JVM will allow while the
            <see cref="T:Disruptor.IEventProcessor"/>s are waiting on a barrier.
            <p>
            This strategy is a good compromise between performance and CPU resource.
            Latency spikes can occur after quiet periods.
            </p>
            </summary>
        </member>
        <member name="M:Disruptor.SleepingWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.SleepingWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.SpinWaitWaitStrategy">
            <summary>
            Spin strategy that uses a <see cref="T:System.Threading.SpinWait"/> for <see cref="T:Disruptor.IEventProcessor"/>s waiting on a barrier.
            <p>
            This strategy is a good compromise between performance and CPU resource.
            Latency spikes can occur after quiet periods.
            </p>
            </summary>
        </member>
        <member name="M:Disruptor.SpinWaitWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.SpinWaitWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="M:Disruptor.TimeoutBlockingWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)"/>
            </summary>
        </member>
        <member name="M:Disruptor.TimeoutBlockingWaitStrategy.SignalAllWhenBlocking">
            <summary>
            <see cref="M:Disruptor.IWaitStrategy.SignalAllWhenBlocking"/>
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer">
             <summary>
             Base type for unmanaged-memory-backed ring buffers.
            
             <see cref="T:Disruptor.UnmanagedRingBuffer`1"/>.
             </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.#ctor(Disruptor.ISequencer,System.IntPtr,System.Int32)">
            <summary>
            Construct a UnmanagedRingBuffer with the full option set.
            </summary>
            <param name="sequencer">sequencer to handle the ordering of events moving through the UnmanagedRingBuffer.</param>
            <param name="pointer">pointer to the first element of the buffer</param>
            <param name="eventSize">size of each event</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="P:Disruptor.UnmanagedRingBuffer.BufferSize">
            <summary>
            Gets the size of the buffer.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.HasAvailableCapacity(System.Int32)">
            <summary>
            Given specified <paramref name="requiredCapacity"/> determines if that amount of space
            is available.  Note, you can not assume that if this method returns <c>true</c>
            that a call to <see cref="M:Disruptor.UnmanagedRingBuffer.Next"/> will not block.  Especially true if this
            ring buffer is set up to handle multiple producers.
            </summary>
            <param name="requiredCapacity">The capacity to check for.</param>
            <returns><c>true</c> if the specified <paramref name="requiredCapacity"/> is available <c>false</c> if not.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.Next">
            <summary>
            Claim an available sequence in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequence afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.UnmanagedRingBuffer.TryNext(System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            long sequence = ringBuffer.Next();
            try
            {
                // Do some work with ringBuffer[sequence];
            }
            finally
            {
                ringBuffer.Publish(sequence);
            }
            </code>
            </para>
            </remarks>
            <returns>The claimed sequence number.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.Next(System.Int32)">
            <summary>
            Claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.UnmanagedRingBuffer.TryNext(System.Int32,System.Int64@)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            long hi = ringBuffer.Next(_batchSize);
            long lo = hi - _batchSize + 1;
            try
            {
                for (long s = lo; s &lt;= hi; s++)
                {
                    // Do some work with ringBuffer[s];
                }
            }
            finally
            {
                ringBuffer.Publish(lo, hi);
            }
            </code>
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <returns>The sequence number of the highest slot claimed.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.TryNext(System.Int64@)">
            <summary>
            Increment and return the next sequence for the ring buffer.  Calls of this
            method should ensure that they always publish the sequence afterward. E.g.
            <code>
            if (!ringBuffer.TryNext(out var sequence))
            {
                // Handle full ring buffer
                return;
            }
            try
            {
                // Do some work with ringBuffer[sequence];
            }
            finally
            {
                ringBuffer.Publish(sequence);
            }
            </code>
            This method will not block if there is not space available in the ring
            buffer, instead it will return false.
            </summary>
            <param name="sequence">the next sequence to publish to</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.TryNext(System.Int32,System.Int64@)">
            <summary>
            Try to claim a range of <paramref name="n"/> available sequences in the ring buffer.
            </summary>
            <remarks>
            <para>
            Calls of this method should ensure that they always publish the sequences afterward.
            </para>
            <para>
            If there is not enough space available in the ring buffer, this method will return false.
            </para>
            <para>
            Example:
            <code>
            if (!ringBuffer.TryNext(_batchSize, out var hi))
            {
                // Handle full ring buffer
                return;
            }
            long lo = hi - _batchSize + 1;
            try
            {
                for (long s = lo; s &lt;= hi; s++)
                {
                    // Do some work with ringBuffer[s];
                }
            }
            finally
            {
                ringBuffer.Publish(lo, hi);
            }
            </code>
            </para>
            </remarks>
            <param name="n">number of slots to claim</param>
            <param name="sequence">sequence number of the highest slot claimed</param>
            <returns>true if the necessary space in the ring buffer is not available, otherwise false.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.ResetTo(System.Int64)">
            <summary>
            Resets the cursor to a specific value.  This can be applied at any time, but it is worth noting
            that it can cause a data race and should only be used in controlled circumstances.  E.g. during
            initialisation.
            </summary>
            <param name="sequence">the sequence to reset too.</param>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.AddGatingSequences(Disruptor.ISequence[])">
            <summary>
            Add the specified gating sequences to this instance of the Disruptor.  They will
            safely and atomically added to the list of gating sequences.
            </summary>
            <param name="gatingSequences">the sequences to add.</param>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.GetMinimumGatingSequence">
            <summary>
            Get the minimum sequence value from all of the gating sequences
            added to this ringBuffer.
            </summary>
            <returns>the minimum gating sequence or the cursor sequence if no sequences have been added.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.RemoveGatingSequence(Disruptor.ISequence)">
            <summary>
            Remove the specified sequence from this ringBuffer.
            </summary>
            <param name="sequence">sequence to be removed.</param>
            <returns><c>true</c> if this sequence was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.NewBarrier(Disruptor.ISequence[])">
            <summary>
            Create a new SequenceBarrier to be used by an EventProcessor to track which messages
            are available to be read from the ring buffer given a list of sequences to track.
            </summary>
            <param name="sequencesToTrack">the additional sequences to track</param>
            <returns>A sequence barrier that will track the specified sequences.</returns>
        </member>
        <member name="P:Disruptor.UnmanagedRingBuffer.Cursor">
            <summary>
            Get the current cursor value for the ring buffer.  The actual value received
            will depend on the type of <see cref="T:Disruptor.ISequencer"/> that is being used.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.Publish(System.Int64)">
            <summary>
            Publish the specified sequence.  This action marks this particular
            message as being available to be read.
            </summary>
            <param name="sequence">the sequence to publish.</param>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.Publish(System.Int64,System.Int64)">
            <summary>
            Publish the specified sequences.  This action marks these particular
            messages as being available to be read.
            </summary>
            <param name="lo">the lowest sequence number to be published</param>
            <param name="hi">the highest sequence number to be published</param>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer.GetRemainingCapacity">
            <summary>
            Get the remaining capacity for this ringBuffer.
            </summary>
            <returns>The number of slots remaining.</returns>
        </member>
        <member name="T:Disruptor.UnmanagedRingBufferMemory">
            <summary>
            Disposable block of unmanaged memory to store events.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBufferMemory.Allocate(System.Int32,System.Int32)">
            <summary>
            Allocate a block of unmanaged memory to store events.
            </summary>
            <param name="eventCount">number of event to store</param>
            <param name="eventSize">size of each event</param>
            <returns></returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBufferMemory.Allocate``1(System.Int32,System.Func{``0})">
            <summary>
            Allocate a block of unmanaged memory to store events.
            </summary>
            <param name="eventCount">number of event to store</param>
            <param name="factory">event factory method</param>
            <returns></returns>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1">
             <summary>
             Ring based store of reusable entries containing the data representing
             an event being exchanged between event producer and <see cref="T:Disruptor.IEventProcessor"/>s.
            
             The underlying storage is an unmanaged buffer. The buffer must be preallocated.
             </summary>
             <typeparam name="T">implementation storing the data for sharing during exchange or parallel coordination of an event.</typeparam>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.#ctor(System.IntPtr,System.Int32,Disruptor.ISequencer)">
            <summary>
            Construct an UnmanagedRingBuffer with the full option set.
            </summary>
            <param name="pointer">pointer to the first element of the buffer</param>
            <param name="eventSize">size of each event</param>
            <param name="sequencer">sequencer to handle the ordering of events moving through the ring buffer.</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.#ctor(Disruptor.UnmanagedRingBufferMemory,Disruptor.Dsl.ProducerType,Disruptor.IWaitStrategy)">
            <summary>
            Construct an UnmanagedRingBuffer with the full option set.
            The <see cref="T:Disruptor.UnmanagedRingBufferMemory"/> is not owned by the ring buffer and should be disposed after shutdown.
            </summary>
            <param name="memory">block of memory that will store the events</param>
            <param name="producerType">producer type to use <see cref="T:Disruptor.Dsl.ProducerType" /></param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="P:Disruptor.UnmanagedRingBuffer`1.Item(System.Int64)">
             <summary>
             Get the event for a given sequence in the RingBuffer.
            
             This call has 2 uses.  Firstly use this call when publishing to a ring buffer.
             After calling <see cref="M:Disruptor.RingBuffer.Next"/> use this call to get hold of the
             preallocated event to fill with data before calling <see cref="M:Disruptor.RingBuffer.Publish(System.Int64)"/>.
            
             Secondly use this call when consuming data from the ring buffer.  After calling
             <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> call this method with any value greater than
             that your current consumer sequence and less than or equal to the value returned from
             the <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> method.
             </summary>
             <param name="sequence">sequence for the event</param>
             <returns>the event for the given sequence</returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.PublishEvent">
            <summary>
            Increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.UnmanagedRingBuffer`1.TryPublishEvent"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvent())
            {
                ref var e = ref scope.Event();
                // Do some work with the event.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.TryPublishEvent">
             <summary>
             Try to increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block if there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent())
             {
                 if (!scope.TryGetEvent(out var eventRef))
                     return;
            
                 ref var e = ref eventRef.Event();
                 // Do some work with the event.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.PublishEvents(System.Int32)">
            <summary>
            Increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.UnmanagedRingBuffer`1.TryPublishEvents(System.Int32)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvents(2))
            {
                ref var e1 = ref scope.Event(0);
                ref var e2 = ref scope.Event(1);
                // Do some work with the events.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.TryPublishEvents(System.Int32)">
             <summary>
             Try to increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block when there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent(2))
             {
                 if (!scope.TryGetEvents(out var eventsRef))
                     return;
            
                 ref var e1 = ref eventRefs.Event(0);
                 ref var e2 = ref eventRefs.Event(1);
                 // Do some work with the events.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventScope.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventBatchScope.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.UnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence number batch.
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventScope.HasEvent">
            <summary>
            Returns a value indicating whether the sequence was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventScope.TryGetEvent(Disruptor.UnmanagedRingBuffer{`0}.EventRef@)">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
            <returns>
            true if the sequence number was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.EventRef">
            <summary>
            Holds an unpublished sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.EventRef.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventBatchScope.HasEvents">
            <summary>
            Returns a value indicating whether the sequence batch was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventBatchScope.TryGetEvents(Disruptor.UnmanagedRingBuffer{`0}.EventBatchRef@)">
            <summary>
            Gets the events for the associated sequence number batch.
            </summary>
            <returns>
            true if the sequence batch was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.NullableUnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence batch if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.UnmanagedRingBuffer`1.EventBatchRef">
            <summary>
            Holds an unpublished sequence number batch.
            </summary>
        </member>
        <member name="M:Disruptor.UnmanagedRingBuffer`1.EventBatchRef.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="T:Disruptor.AggressiveSpinWait">
             <summary>
             Provides support for spin-based waiting, without using <code>Thread.Sleep(1)</code>.
             </summary>
             <remarks>
             <para>
             Using this type is less aggressive than a busy-spin. The use of <code>Thread.Sleep(0)</code> allows the thread to give up
             its time-slice, thus preventing starvation.
            </para>
             <para>
             Using this type is more aggressive than a <see cref="T:System.Threading.SpinWait"/>. <code>Thread.Sleep(1)</code> is not used to avoid generating pauses
             that are not acceptable for many low latency use cases.
             </para>
             </remarks>
        </member>
        <member name="T:Disruptor.ThrowHelper">
            <summary>
            Expose non-inlinable methods to throw exceptions.
            </summary>
        </member>
        <member name="T:Disruptor.Util">
            <summary>
            Set of common functions used by the Disruptor
            </summary>
        </member>
        <member name="F:Disruptor.Util.RingBufferPaddingBytes">
             <summary>
             Ring buffer padding size in bytes.
            
             The padding should be added at the beginning and at the end of the
             ring buffer arrays.
            
             Used to avoid false sharing.
             </summary>
        </member>
        <member name="M:Disruptor.Util.GetRingBufferPaddingEventCount(System.Int32)">
            <summary>
            Gets the ring buffer padding as a number of events.
            </summary>
            <param name="eventSize"></param>
            <returns></returns>
        </member>
        <member name="M:Disruptor.Util.CeilingNextPowerOfTwo(System.Int32)">
            <summary>
            Calculate the next power of 2, greater than or equal to x.
            </summary>
            <param name="x">Value to round up</param>
            <returns>The next power of 2 from x inclusive</returns>
        </member>
        <member name="M:Disruptor.Util.Log2(System.Int32)">
            <summary>
            Calculate the log base 2 of the supplied integer, essentially reports the location
            of the highest bit.
            </summary>
            <param name="i">Value to calculate log2 for.</param>
            <returns>The log2 value</returns>
        </member>
        <member name="M:Disruptor.Util.IsPowerOf2(System.Int32)">
            <summary>
            Test whether a given integer is a power of 2
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Disruptor.Util.GetMinimumSequence(Disruptor.ISequence[],System.Int64)">
            <summary>
            Get the minimum sequence from an array of <see cref="T:Disruptor.Sequence"/>s.
            </summary>
            <param name="sequences">sequences to compare.</param>
            <param name="minimum">an initial default minimum.  If the array is empty this value will returned.</param>
            <returns>the minimum sequence found or lon.MaxValue if the array is empty.</returns>
        </member>
        <member name="M:Disruptor.Util.GetSequencesFor(Disruptor.IEventProcessor[])">
            <summary>
            Get an array of <see cref="T:Disruptor.Sequence"/>s for the passed <see cref="T:Disruptor.IEventProcessor"/>s
            </summary>
            <param name="processors">processors for which to get the sequences</param>
            <returns>the array of <see cref="T:Disruptor.Sequence"/>s</returns>
        </member>
        <member name="T:Disruptor.ValueBatchEventProcessor`5">
             <summary>
             Convenience class for handling the batching semantics of consuming events from a <see cref="T:Disruptor.ValueRingBuffer`1"/>
             and delegating the available events to an <see cref="T:Disruptor.IValueEventHandler`1"/>.
            
             If the <see cref="T:Disruptor.IValueEventHandler`1"/> also implements <see cref="T:Disruptor.ILifecycleAware"/> it will be notified just after the thread
             is started and just before the thread is shutdown.
             </summary>
             <typeparam name="T">the type of event used.</typeparam>
             <typeparam name="TDataProvider">the type of the <see cref="T:Disruptor.IValueDataProvider`1"/> used.</typeparam>
             <typeparam name="TSequenceBarrier">the type of the <see cref="T:Disruptor.ISequenceBarrier"/> used.</typeparam>
             <typeparam name="TEventHandler">the type of the <see cref="T:Disruptor.IValueEventHandler`1"/> used.</typeparam>
             <typeparam name="TBatchStartAware">the type of the <see cref="T:Disruptor.IBatchStartAware"/> used.</typeparam>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.#ctor(`1,`2,`3,`4)">
             <summary>
             Construct a BatchEventProcessor that will automatically track the progress by updating its sequence when
             the <see cref="M:Disruptor.IValueEventHandler`1.OnEvent(`0@,System.Int64,System.Boolean)"/> method returns.
            
             Consider using <see cref="T:Disruptor.BatchEventProcessorFactory"/> to create your <see cref="T:Disruptor.IEventProcessor"/>.
             </summary>
             <param name="dataProvider">dataProvider to which events are published</param>
             <param name="sequenceBarrier">SequenceBarrier on which it is waiting.</param>
             <param name="eventHandler">eventHandler is the delegate to which events are dispatched.</param>
             <param name="batchStartAware"></param>
        </member>
        <member name="P:Disruptor.ValueBatchEventProcessor`5.Sequence">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.Sequence"/>
            </summary>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.Halt">
            <summary>
            Signal that this <see cref="T:Disruptor.IEventProcessor"/> should stop when it has finished consuming at the next clean break.
            It will call <see cref="M:Disruptor.ISequenceBarrier.Alert"/> to notify the thread to check status.
            </summary>
        </member>
        <member name="P:Disruptor.ValueBatchEventProcessor`5.IsRunning">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.IsRunning"/>
            </summary>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.SetExceptionHandler(Disruptor.IValueExceptionHandler{`0})">
            <summary>
            Set a new <see cref="T:Disruptor.IValueExceptionHandler`1"/> for handling exceptions propagated out of the <see cref="T:Disruptor.IValueEventHandler`1"/>
            </summary>
            <param name="exceptionHandler">exceptionHandler to replace the existing exceptionHandler.</param>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.WaitUntilStarted(System.TimeSpan)">
            <summary>
            Waits before the event processor enters the <see cref="P:Disruptor.ValueBatchEventProcessor`5.IsRunning"/> state.
            </summary>
            <param name="timeout">maximum wait duration</param>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.Run">
            <summary>
            It is ok to have another thread rerun this method after a halt().
            </summary>
            <exception cref="T:System.InvalidOperationException">if this object instance is already running in a thread</exception>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.NotifyStart">
            <summary>
            Notifies the EventHandler when this processor is starting up
            </summary>
        </member>
        <member name="M:Disruptor.ValueBatchEventProcessor`5.NotifyShutdown">
            <summary>
            Notifies the EventHandler immediately prior to this processor shutting down
            </summary>
        </member>
        <member name="T:Disruptor.ValueEventPoller`1">
            <summary>
            Experimental poll-based interface for the Disruptor.
            </summary>
        </member>
        <member name="T:Disruptor.ValueFatalExceptionHandler`1">
            <summary>
            Convenience implementation of an exception handler that using standard Console.Writeline to log
            the exception re-throw it wrapped in a <see cref="T:System.ApplicationException"/>
            </summary>
        </member>
        <member name="M:Disruptor.ValueFatalExceptionHandler`1.HandleEventException(System.Exception,System.Int64,`0@)">
            <summary>
            Strategy for handling uncaught exceptions when processing an event.
            </summary>
            <param name="ex">exception that propagated from the <see cref="T:Disruptor.IEventHandler`1"/>.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
            <param name="evt">event being processed when the exception occurred.</param>
        </member>
        <member name="M:Disruptor.ValueFatalExceptionHandler`1.HandleOnTimeoutException(System.Exception,System.Int64)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ITimeoutHandler.OnTimeout(System.Int64)"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
            <param name="sequence">sequence of the event which cause the exception.</param>
        </member>
        <member name="M:Disruptor.ValueFatalExceptionHandler`1.HandleOnStartException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnStart"/>
            </summary>
            <param name="ex">ex throw during the starting process.</param>
        </member>
        <member name="M:Disruptor.ValueFatalExceptionHandler`1.HandleOnShutdownException(System.Exception)">
            <summary>
            Callback to notify of an exception during <see cref="M:Disruptor.ILifecycleAware.OnShutdown"/>
            </summary>
            <param name="ex">ex throw during the shutdown process.</param>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1">
            <summary>
            Ring based store of reusable entries containing the data representing
            an event being exchanged between event producer and <see cref="T:Disruptor.IEventProcessor"/>s.
            </summary>
            <typeparam name="T">implementation storing the data for sharing during exchange or parallel coordination of an event.</typeparam>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.#ctor(Disruptor.ISequencer)">
            <summary>
            Construct a ValueRingBuffer with the full option set.
            </summary>
            <param name="sequencer">sequencer to handle the ordering of events moving through the ring buffer.</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.#ctor(System.Func{`0},Disruptor.ISequencer)">
            <summary>
            Construct a ValueRingBuffer with the full option set.
            </summary>
            <param name="eventFactory">eventFactory to create entries for filling the ring buffer</param>
            <param name="sequencer">sequencer to handle the ordering of events moving through the ring buffer.</param>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            Construct a ValueRingBuffer with a <see cref="T:Disruptor.MultiProducerSequencer"/> sequencer.
            </summary>
            <param name="eventFactory"> eventFactory to create entries for filling the ring buffer</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.CreateMultiProducer(System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new multiple producer ValueRingBuffer with the specified wait strategy.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.CreateMultiProducer(System.Func{`0},System.Int32)">
            <summary>
            Create a new multiple producer ValueRingBuffer using the default wait strategy <see cref="T:Disruptor.BlockingWaitStrategy"/>.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.CreateSingleProducer(System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new single producer ValueRingBuffer with the specified wait strategy.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.CreateSingleProducer(System.Func{`0},System.Int32)">
            <summary>
            Create a new single producer ValueRingBuffer using the default wait strategy <see cref="T:Disruptor.BlockingWaitStrategy"/>.
            </summary>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.Create(Disruptor.Dsl.ProducerType,System.Func{`0},System.Int32,Disruptor.IWaitStrategy)">
            <summary>
            Create a new ValueRingBuffer with the specified producer type.
            </summary>
            <param name="producerType">producer type to use <see cref="T:Disruptor.Dsl.ProducerType" /></param>
            <param name="factory">used to create the events within the ring buffer.</param>
            <param name="bufferSize">number of elements to create within the ring buffer.</param>
            <param name="waitStrategy">used to determine how to wait for new elements to become available.</param>
            <returns>a constructed ring buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the producer type is invalid</exception>
            <exception cref="T:System.ArgumentException">if bufferSize is less than 1 or not a power of 2</exception>
        </member>
        <member name="P:Disruptor.ValueRingBuffer`1.Item(System.Int64)">
             <summary>
             Get the event for a given sequence in the RingBuffer.
            
             This call has 2 uses.  Firstly use this call when publishing to a ring buffer.
             After calling <see cref="M:Disruptor.RingBuffer.Next"/> use this call to get hold of the
             preallocated event to fill with data before calling <see cref="M:Disruptor.RingBuffer.Publish(System.Int64)"/>.
            
             Secondly use this call when consuming data from the ring buffer.  After calling
             <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> call this method with any value greater than
             that your current consumer sequence and less than or equal to the value returned from
             the <see cref="M:Disruptor.ISequenceBarrier.WaitFor(System.Int64)"/> method.
             </summary>
             <param name="sequence">sequence for the event</param>
             <returns>the event for the given sequence</returns>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.ClaimAndGetPreallocated(System.Int64)">
            <summary>
            Sets the cursor to a specific sequence and returns the preallocated entry that is stored there.  This
            can cause a data race and should only be done in controlled circumstances, e.g. during initialisation.
            </summary>
            <param name="sequence">the sequence to claim.</param>
            <returns>the preallocated event.</returns>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.NewPoller(Disruptor.ISequence[])">
            <summary>
            Creates an event poller for this ring buffer gated on the supplied sequences.
            </summary>
            <param name="gatingSequences">gatingSequences to be gated on.</param>
            <returns>A poller that will gate on this ring buffer and the supplied sequences.</returns>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.PublishEvent">
            <summary>
            Increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.ValueRingBuffer`1.TryPublishEvent"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvent())
            {
                ref var e = ref scope.Event();
                // Do some work with the event.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.TryPublishEvent">
             <summary>
             Try to increment the ring buffer sequence and return a scope that will publish the sequence on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block if there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent())
             {
                 if (!scope.TryGetEvent(out var eventRef))
                     return;
            
                 ref var e = ref eventRef.Event();
                 // Do some work with the event.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.PublishEvents(System.Int32)">
            <summary>
            Increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
            </summary>
            <remarks>
            <para>
            If there is not enough space available in the ring buffer, this method will block and spin-wait using <see cref="T:Disruptor.AggressiveSpinWait"/>, which can generate high CPU usage.
            Consider using <see cref="M:Disruptor.ValueRingBuffer`1.TryPublishEvents(System.Int32)"/> with your own waiting policy if you need to change this behavior.
            </para>
            <para>
            Example:
            <code>
            using (var scope = _ringBuffer.PublishEvents(2))
            {
                ref var e1 = ref scope.Event(0);
                ref var e2 = ref scope.Event(1);
                // Do some work with the events.
            }
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.TryPublishEvents(System.Int32)">
             <summary>
             Try to increment the ring buffer sequence by <paramref name="count"/> and return a scope that will publish the sequences on disposing.
             </summary>
             <remarks>
             <para>
             This method will not block when there is not enough space available in the ring buffer.
             </para>
             <para>
             Example:
             <code>
             using (var scope = _ringBuffer.TryPublishEvent(2))
             {
                 if (!scope.TryGetEvents(out var eventsRef))
                     return;
            
                 ref var e1 = ref eventRefs.Event(0);
                 ref var e2 = ref eventRefs.Event(1);
                 // Do some work with the events.
             }
             </code>
             </para>
             </remarks>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.UnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.UnpublishedEventScope.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.UnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.UnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.UnpublishedEventBatchScope.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.UnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence number batch.
            </summary>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventScope">
            <summary>
            Holds an unpublished sequence number.
            Publishes the sequence number on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventScope.HasEvent">
            <summary>
            Returns a value indicating whether the sequence was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventScope.TryGetEvent(Disruptor.ValueRingBuffer{`0}.EventRef@)">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
            <returns>
            true if the sequence number was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventScope.Dispose">
            <summary>
            Publishes the sequence number if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.EventRef">
            <summary>
            Holds an unpublished sequence number.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.EventRef.Event">
            <summary>
            Gets the event at the claimed sequence number.
            </summary>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventBatchScope">
            <summary>
            Holds an unpublished sequence number batch.
            Publishes the sequence numbers on disposing.
            </summary>
        </member>
        <member name="P:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventBatchScope.HasEvents">
            <summary>
            Returns a value indicating whether the sequence batch was successfully claimed.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventBatchScope.TryGetEvents(Disruptor.ValueRingBuffer{`0}.EventBatchRef@)">
            <summary>
            Gets the events for the associated sequence number batch.
            </summary>
            <returns>
            true if the sequence batch was successfully claimed, false otherwise.
            </returns>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.NullableUnpublishedEventBatchScope.Dispose">
            <summary>
            Publishes the sequence batch if it was successfully claimed.
            </summary>
        </member>
        <member name="T:Disruptor.ValueRingBuffer`1.EventBatchRef">
            <summary>
            Holds an unpublished sequence number batch.
            </summary>
        </member>
        <member name="M:Disruptor.ValueRingBuffer`1.EventBatchRef.Event(System.Int32)">
            <summary>
            Gets the event at the specified index in the claimed sequence batch.
            </summary>
        </member>
        <member name="T:Disruptor.WorkerPool`1">
            <summary>
            WorkerPool contains a pool of <see cref="T:Disruptor.WorkProcessor`1"/> that will consume sequences so jobs can be farmed out across a pool of workers.
            Each of the <see cref="T:Disruptor.WorkProcessor`1"/> manage and calls a <see cref="T:Disruptor.IWorkHandler`1"/> to process the events.
            </summary>
            <typeparam name="T">event to be processed by a pool of workers</typeparam>
        </member>
        <member name="M:Disruptor.WorkerPool`1.#ctor(Disruptor.RingBuffer{`0},Disruptor.ISequenceBarrier,Disruptor.IExceptionHandler{`0},Disruptor.IWorkHandler{`0}[])">
            <summary>
            Create a worker pool to enable an array of <see cref="T:Disruptor.IWorkHandler`1"/>s to consume published sequences.
            
            This option requires a pre-configured <see cref="T:Disruptor.RingBuffer`1"/> which must have <see cref="M:Disruptor.ISequencer.AddGatingSequences(Disruptor.ISequence[])"/>
            called before the work pool is started.
            </summary>
            <param name="ringBuffer">ringBuffer of events to be consumed.</param>
            <param name="sequenceBarrier">sequenceBarrier on which the workers will depend.</param>
            <param name="exceptionHandler">exceptionHandler to callback when an error occurs which is not handled by the <see cref="T:Disruptor.IWorkHandler`1"/>s.</param>
            <param name="workHandlers">workHandlers to distribute the work load across.</param>
        </member>
        <member name="M:Disruptor.WorkerPool`1.#ctor(System.Func{`0},Disruptor.IExceptionHandler{`0},Disruptor.IWorkHandler{`0}[])">
            <summary>
            Construct a work pool with an internal <see cref="T:Disruptor.RingBuffer`1"/> for convenience.
            
            This option does not require <see cref="M:Disruptor.ISequencer.AddGatingSequences(Disruptor.ISequence[])"/> to be called before the work pool is started.
            </summary>
            <param name="eventFactory">eventFactory for filling the <see cref="T:Disruptor.RingBuffer`1"/></param>
            <param name="exceptionHandler">exceptionHandler to callback when an error occurs which is not handled by the <see cref="T:Disruptor.IWorkHandler`1"/>s.</param>
            <param name="workHandlers">workHandlers to distribute the work load across.</param>
        </member>
        <member name="M:Disruptor.WorkerPool`1.GetWorkerSequences">
            <summary>
            Get an array of <see cref="T:Disruptor.Sequence"/>s representing the progress of the workers.
            </summary>
        </member>
        <member name="M:Disruptor.WorkerPool`1.Start(Disruptor.Dsl.IExecutor)">
            <summary>
            Start the worker pool processing events in sequence.
            </summary>
            <returns>the <see cref="T:Disruptor.RingBuffer`1"/> used for the work queue.</returns>
            <exception cref="T:System.InvalidOperationException">if the pool has already been started and not halted yet</exception>
        </member>
        <member name="M:Disruptor.WorkerPool`1.DrainAndHalt">
            <summary>
            Wait for the <see cref="T:Disruptor.RingBuffer`1"/> to drain of published events then halt the workers.
            </summary>
        </member>
        <member name="M:Disruptor.WorkerPool`1.Halt">
            <summary>
            Halt all workers immediately at then end of their current cycle.
            </summary>
        </member>
        <member name="T:Disruptor.WorkProcessor`1">
             <summary>
             A <see cref="T:Disruptor.WorkProcessor`1"/> wraps a single <see cref="T:Disruptor.IWorkHandler`1"/>, effectively consuming the sequence and ensuring appropriate barriers.
            
             Generally, this will be used as part of a <see cref="T:Disruptor.WorkerPool`1"/>.
             </summary>
             <typeparam name="T">event implementation storing the details for the work to processed.</typeparam>
        </member>
        <member name="M:Disruptor.WorkProcessor`1.#ctor(Disruptor.RingBuffer{`0},Disruptor.ISequenceBarrier,Disruptor.IWorkHandler{`0},Disruptor.IExceptionHandler{`0},Disruptor.Sequence)">
            <summary>
            Construct a <see cref="T:Disruptor.WorkProcessor`1"/>.
            </summary>
            <param name="ringBuffer">ringBuffer to which events are published.</param>
            <param name="sequenceBarrier">sequenceBarrier on which it is waiting.</param>
            <param name="workHandler">workHandler is the delegate to which events are dispatched.</param>
            <param name="exceptionHandler">exceptionHandler to be called back when an error occurs</param>
            <param name="workSequence">workSequence from which to claim the next event to be worked on.  It should always be initialised
            as <see cref="F:Disruptor.Sequence.InitialCursorValue"/></param>
        </member>
        <member name="P:Disruptor.WorkProcessor`1.Sequence">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.Sequence"/>.
            </summary>
        </member>
        <member name="M:Disruptor.WorkProcessor`1.Halt">
            <summary>
            <see cref="M:Disruptor.IEventProcessor.Halt"/>.
            </summary>
        </member>
        <member name="M:Disruptor.WorkProcessor`1.HaltLater">
            <summary>
            Signal that this <see cref="T:Disruptor.WorkProcessor`1"/> should stop when it has finished processing its work sequence.
            </summary>
        </member>
        <member name="P:Disruptor.WorkProcessor`1.IsRunning">
            <summary>
            <see cref="P:Disruptor.IEventProcessor.IsRunning"/>
            </summary>
        </member>
        <member name="M:Disruptor.WorkProcessor`1.Run">
            <summary>
            <see cref="M:Disruptor.IEventProcessor.Run"/>.
            </summary>
        </member>
        <member name="T:Disruptor.YieldingWaitStrategy">
            <summary>
            Yielding strategy that uses a Thread.Yield() for <see cref="T:Disruptor.IEventProcessor"/>s waiting on a barrier
            after an initially spinning.
            
            This strategy is a good compromise between performance and CPU resource without incurring significant latency spikes.
            </summary>
        </member>
        <member name="M:Disruptor.YieldingWaitStrategy.WaitFor(System.Int64,Disruptor.Sequence,Disruptor.ISequence,Disruptor.ISequenceBarrier)">
            <summary>
            Wait for the given sequence to be available
            <para>This strategy is a good compromise between performance and CPU resource without incurring significant latency spikes.</para>
            </summary>
            <param name="sequence">sequence to be waited on.</param>
            <param name="cursor">Ring buffer cursor on which to wait.</param>
            <param name="dependentSequence">dependents further back the chain that must advance first</param>
            <param name="barrier">barrier the <see cref="T:Disruptor.IEventProcessor"/> is waiting on.</param>
            <returns>the sequence that is available which may be greater than the requested sequence.</returns>
        </member>
        <member name="M:Disruptor.YieldingWaitStrategy.SignalAllWhenBlocking">
            <summary>
            Signal those <see cref="T:Disruptor.IEventProcessor"/> waiting that the cursor has advanced.
            </summary>
        </member>
    </members>
</doc>
